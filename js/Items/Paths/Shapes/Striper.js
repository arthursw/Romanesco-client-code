// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['Items/Paths/Shapes/Shape', 'UI/Modal'], function(Shape, Modal) {
    var Striper;
    Striper = (function(superClass) {
      extend(Striper, superClass);

      function Striper() {
        this.allRastersLoaded = bind(this.allRastersLoaded, this);
        return Striper.__super__.constructor.apply(this, arguments);
      }

      Striper.Shape = P.Path.Rectangle;

      Striper.label = 'Striper';

      Striper.description = "Creates a striped version of an SVG.";

      Striper.squareByDefault = true;

      Striper.initializeParameters = function() {
        var parameters;
        parameters = Striper.__super__.constructor.initializeParameters.call(this);
        parameters['Style'].strokeWidth["default"] = 1;
        parameters['Style'].strokeColor["default"] = 'black';
        parameters['Style'].strokeColor.defaultFunction = null;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].effectType = {
          "default": 'CMYKstripes',
          values: ['CMYKstripes', 'CMYKdots'],
          label: 'Effect type'
        };
        parameters['Parameters'].pixelSize = {
          type: 'slider',
          label: 'pixelSize',
          min: 1,
          max: 16,
          "default": 7
        };
        parameters['Parameters'].nStripes = {
          type: 'slider',
          label: 'nStripes',
          min: 10,
          max: 160,
          "default": 15
        };
        parameters['Parameters'].blackThreshold = {
          type: 'slider',
          label: 'blackThreshold',
          min: 0,
          max: 255,
          "default": 50
        };
        parameters['Parameters'].cyanThreshold = {
          type: 'slider',
          label: 'cyanThreshold',
          min: 0,
          max: 255,
          "default": 128
        };
        parameters['Parameters'].magentaThreshold = {
          type: 'slider',
          label: 'magentaThreshold',
          min: 0,
          max: 255,
          "default": 128
        };
        parameters['Parameters'].yellowThreshold = {
          type: 'slider',
          label: 'yellowThreshold',
          min: 0,
          max: 255,
          "default": 128
        };
        parameters['Parameters'].blackAngle = {
          type: 'slider',
          label: 'blackAngle',
          min: 0,
          max: 360,
          "default": 45
        };
        parameters['Parameters'].cyanAngle = {
          type: 'slider',
          label: 'cyanAngle',
          min: 0,
          max: 360,
          "default": 15
        };
        parameters['Parameters'].magentaAngle = {
          type: 'slider',
          label: 'magentaAngle',
          min: 0,
          max: 360,
          "default": 75
        };
        parameters['Parameters'].yellowAngle = {
          type: 'slider',
          label: 'yellowAngle',
          min: 0,
          max: 360,
          "default": 0
        };
        parameters['Parameters'].dotSize = {
          type: 'slider',
          label: 'dotSize',
          min: 0.1,
          max: 10,
          "default": 2
        };
        parameters['Parameters'].removeContours = {
          type: 'checkbox',
          label: 'remove contours',
          "default": true
        };
        return parameters;
      };

      Striper.parameters = Striper.initializeParameters();

      Striper.createTool(Striper);

      Striper.prototype.initialize = function() {
        var modal;
        if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
          console.log('File upload not supported.');
          R.alertManager.alert('File upload not supported', 'error');
          return;
        }
        modal = Modal.createModal({
          title: 'Select an image',
          submit: function() {}
        });
        modal.addImageSelector({
          name: "image-selector",
          svg: true,
          rastersLoadedCallback: this.allRastersLoaded,
          extractor: (function(_this) {
            return function() {
              return _this.rasters.length > 0;
            };
          })(this)
        });
        modal.show();
      };

      Striper.prototype.allRastersLoaded = function(rasters) {
        var file, raster;
        if (((this.rasters == null) || this.rasters.length === 0) && (rasters == null)) {
          return;
        }
        if (this.rasters == null) {
          this.rasters = [];
          for (file in rasters) {
            raster = rasters[file];
            this.rasters.push(raster);
          }
        }
        switch (this.data.effectType) {
          case 'CMYKstripes':
            this.drawCMYKstripes();
            break;
          case 'CMYKdots':
            this.drawCMYKdots();
        }
      };

      Striper.prototype.colorToCMYK = function(color) {
        var b, g, k, r, result;
        r = color.red;
        g = color.green;
        b = color.blue;
        k = Math.min(1 - r, 1 - g, 1 - b);
        result = {
          c: (1 - r - k) / (1 - k) || 0,
          m: (1 - g - k) / (1 - k) || 0,
          y: (1 - b - k) / (1 - k) || 0,
          k: k
        };
        return result;
      };

      Striper.prototype.drawCMYKdots = function() {
        var angle, c, center, color, colors, colorsToAngles, colorsToNames, colorsToThreshold, cymk, deltaX, deltaY, dot, i, j, l, len, m, maxSize, n, nSteps, path, pixel, position, previousColor, raster, ref, ref1, square, startPosition;
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        maxSize = Math.max(this.rectangle.width, this.rectangle.height);
        square = new P.Rectangle(maxSize, maxSize);
        pixel = new P.Rectangle(-this.data.pixelSize / 2, -this.data.pixelSize / 2, this.data.pixelSize, this.data.pixelSize);
        nSteps = maxSize / this.data.pixelSize;
        colorsToNames = {
          c: 'cyan',
          m: 'magenta',
          y: 'yellow',
          k: 'black'
        };
        colorsToAngles = {
          c: this.data.cyanAngle,
          m: this.data.magentaAngle,
          y: this.data.yellowAngle,
          k: this.data.blackAngle
        };
        colorsToThreshold = {
          c: this.data.cyanThreshold,
          m: this.data.magentaThreshold,
          y: this.data.yellowThreshold,
          k: this.data.blackThreshold
        };
        colors = ['k', 'm', 'c', 'y'];
        for (l = 0, len = colors.length; l < len; l++) {
          c = colors[l];
          angle = colorsToAngles[c];
          center = this.rectangle.center;
          position = center.subtract(maxSize / 2);
          position = position.rotate(angle, center);
          deltaX = new P.Point(1, 0).rotate(angle).multiply(this.data.pixelSize);
          deltaY = new P.Point(0, 1).rotate(angle).multiply(this.data.pixelSize);
          previousColor = null;
          path = null;
          for (i = m = 0, ref = nSteps; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
            startPosition = position.clone();
            if (i % 2 === 0) {
              position = position.add(deltaX.divide(2));
            }
            for (j = n = 0, ref1 = nSteps; 0 <= ref1 ? n <= ref1 : n >= ref1; j = 0 <= ref1 ? ++n : --n) {
              if (position.x === 0) {
                position.x = 0.001;
              }
              color = raster.getAverageColor(position);
              if (color != null) {
                cymk = this.colorToCMYK(color);
                dot = this.addPath(new P.Path.Circle(position, cymk[c] * this.data.pixelSize * this.data.dotSize));
                dot.fillColor = colorsToNames[c];
                dot.strokeWidth = 0;
              }
              position = position.add(deltaX);
            }
            position = startPosition.add(deltaY);
          }
        }
      };

      Striper.prototype.logItem = function(item, prefix) {
        var child, l, len, ref;
        if (prefix == null) {
          prefix = "";
        }
        console.log(prefix + item.className);
        prefix += " -";
        if (item.children == null) {
          return;
        }
        ref = item.children;
        for (l = 0, len = ref.length; l < len; l++) {
          child = ref[l];
          this.logItem(child, prefix);
        }
      };

      Striper.prototype.convertGroupsToCompoundPath = function(item, compoundPath) {
        var child, l, len, ref;
        if ((item instanceof P.Group || item instanceof P.CompoundPath) && (item.children != null)) {
          ref = item.children;
          for (l = 0, len = ref.length; l < len; l++) {
            child = ref[l];
            this.convertGroupsToCompoundPath(child, compoundPath);
          }
        } else if (item != null) {
          console.log(item.className);
          compoundPath.addChild(item.clone());
        }
      };

      Striper.prototype.drawCMYKstripes = function() {
        var angles, center, colors, colorsToAngles, colorsToNames, colorsToThreshold, i, l, len, len1, line, m, maxSize, n, nSteps, originalRaster, p, path, pathWithoutContour, pixel, position, raster, ref, ref1, ref2, segment, square, stripe, stripes, yStepSize;
        originalRaster = this.rasters[0].clone();
        originalRaster.fitBounds(this.rectangle, false);
        raster = new P.CompoundPath();
        this.convertGroupsToCompoundPath(originalRaster, raster);
        console.log("originalRaster");
        this.logItem(originalRaster);
        console.log("raster");
        this.logItem(raster);
        raster.position = this.rectangle.center;
        raster.fitBounds(this.rectangle, false);
        maxSize = Math.max(this.rectangle.width, this.rectangle.height);
        square = new P.Rectangle(maxSize, maxSize);
        pixel = new P.Rectangle(-this.data.pixelSize / 2, -this.data.pixelSize / 2, this.data.pixelSize, this.data.pixelSize);
        nSteps = maxSize / this.data.pixelSize;
        yStepSize = maxSize / this.data.nStripes;
        colorsToNames = {
          c: 'cyan',
          m: 'magenta',
          y: 'yellow',
          k: 'black'
        };
        colorsToAngles = {
          c: this.data.cyanAngle,
          m: this.data.magentaAngle,
          y: this.data.yellowAngle,
          k: this.data.blackAngle
        };
        colorsToThreshold = {
          c: this.data.cyanThreshold,
          m: this.data.magentaThreshold,
          y: this.data.yellowThreshold,
          k: this.data.blackThreshold
        };
        colors = ['k', 'm', 'c', 'y'];
        angles = [15, 75, 0, 45];
        stripes = new P.CompoundPath();
        stripes.strokeWidth = 1;
        stripes.strokeColor = 'black';
        center = this.rectangle.center;
        position = center.subtract(maxSize / 2);
        for (i = l = 0, ref = this.data.nStripes; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
          stripe = new P.Path.Rectangle(position, new P.Size(maxSize, yStepSize / 2));
          stripe.fillColor = 'black';
          stripes.addChild(stripe);
          position = position.add(0, yStepSize);
        }
        path = stripes.intersect(raster.clone());
        if (this.data.removeContours) {
          pathWithoutContour = new P.CompoundPath();
          ref1 = path.children;
          for (m = 0, len = ref1.length; m < len; m++) {
            p = ref1[m];
            ref2 = p.segments;
            for (n = 0, len1 = ref2.length; n < len1; n++) {
              segment = ref2[n];
              if ((segment.next != null) && Math.abs(segment.point.y - segment.next.point.y) < 1.5) {
                line = new P.Path();
                line.add(segment.point);
                line.add(segment.next.point);
                pathWithoutContour.addChild(line);
              }
            }
          }
          path.remove();
          path = pathWithoutContour;
        }
        path.strokeWidth = 1;
        path.strokeColor = 'black';
        this.drawing.addChild(path);
        this.drawing.addChild(raster);
        raster.fillColor = null;
        raster.strokeColor = 'black';
        raster.strokeWidth = 1;
        stripes.remove();
      };

      Striper.prototype.createShape = function() {
        this.shape = new P.Group();
        this.allRastersLoaded();
      };

      return Striper;

    })(Shape);
    return Striper;
  });

}).call(this);
