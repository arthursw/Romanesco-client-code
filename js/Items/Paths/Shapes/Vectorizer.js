// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['Items/Paths/Shapes/Shape', 'UI/Modal'], function(Shape, Modal) {
    var Vectorizer;
    Vectorizer = (function(superClass) {
      extend(Vectorizer, superClass);

      function Vectorizer() {
        this.allRastersLoaded = bind(this.allRastersLoaded, this);
        return Vectorizer.__super__.constructor.apply(this, arguments);
      }

      Vectorizer.Shape = P.Path.Rectangle;

      Vectorizer.label = 'Vectorizer';

      Vectorizer.description = "Creates a vectorized version of an image.";

      Vectorizer.squareByDefault = true;

      Vectorizer.initializeParameters = function() {
        var parameters;
        parameters = Vectorizer.__super__.constructor.initializeParameters.call(this);
        parameters['Style'].strokeWidth["default"] = 1;
        parameters['Style'].strokeColor["default"] = 'black';
        parameters['Style'].strokeColor.defaultFunction = null;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].effectType = {
          "default": 'multipleStrokes',
          values: ['multipleStrokes', 'color', 'blackAndWhite'],
          label: 'Effect type'
        };
        parameters['Parameters'].nStrokes = {
          type: 'slider',
          label: 'StrokeNumber',
          min: 2,
          max: 16,
          "default": 4
        };
        parameters['Parameters'].spiralWidth = {
          type: 'slider',
          label: 'Spiral width',
          min: 1,
          max: 16,
          "default": 7
        };
        return parameters;
      };

      Vectorizer.parameters = Vectorizer.initializeParameters();

      Vectorizer.createTool(Vectorizer);

      Vectorizer.prototype.initialize = function() {
        var modal;
        if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
          console.log('File upload not supported.');
          R.alertManager.alert('File upload not supported', 'error');
          return;
        }
        modal = Modal.createModal({
          title: 'Select an image',
          submit: function() {}
        });
        modal.addImageSelector({
          name: "image-selector",
          rastersLoadedCallback: this.allRastersLoaded,
          extractor: (function(_this) {
            return function() {
              return _this.rasters.length > 0;
            };
          })(this)
        });
        modal.show();
      };

      Vectorizer.prototype.allRastersLoaded = function(rasters) {
        var file, raster;
        if (((this.rasters == null) || this.rasters.length === 0) && (rasters == null)) {
          return;
        }
        if (this.rasters == null) {
          this.rasters = [];
          for (file in rasters) {
            raster = rasters[file];
            this.rasters.push(raster);
          }
        }
        switch (this.data.effectType) {
          case 'multipleStrokes':
            this.drawSpiralMultipleStrokes();
            break;
          case 'color':
            this.drawSpiralColor();
            break;
          case 'blackAndWhite':
            this.drawSpiralColor(true);
        }
      };

      Vectorizer.prototype.drawSpiralColor = function(blackAndWhite) {
        var c, color, colors, count, l, len, len1, n, offset, offsets, path, position, raster, ref, rot, v, value, vector;
        if (blackAndWhite == null) {
          blackAndWhite = false;
        }
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        colors = blackAndWhite ? ['black'] : ['red', 'green', 'blue'];
        offsets = blackAndWhite ? {
          'black': 0
        } : {
          'red': -3.7 / 1.5,
          'green': 0,
          'blue': 3.7 / 1.5
        };
        this.paths = {};
        for (l = 0, len = colors.length; l < len; l++) {
          color = colors[l];
          path = this.addPath(new P.Path());
          path.fillColor = color;
          path.strokeColor = null;
          path.strokeWidth = 0;
          path.closed = true;
          this.paths[color] = path;
        }
        position = this.rectangle.center;
        count = 0;
        while (this.rectangle.center.subtract(position).length < this.rectangle.width / 2) {
          vector = new P.Point({
            angle: count * 5,
            length: count / 100
          });
          rot = vector.rotate(90);
          offset = rot.clone();
          offset.length = 1;
          color = raster.getAverageColor(position.add(vector.divide(2)));
          for (n = 0, len1 = colors.length; n < len1; n++) {
            c = colors[n];
            v = blackAndWhite ? color.gray : color[c];
            value = color ? (1 - v) * this.data.spiralWidth / 2.5 : 0;
            rot.length = Math.max(value, 0.1);
            this.paths[c].add(position.add(vector).add(offset.multiply(offsets[c])).subtract(rot));
            this.paths[c].insert(0, position.add(vector).add(offset.multiply(offsets[c])).add(rot));
          }
          position = position.add(vector);
          count++;
        }
        ref = this.paths;
        for (color in ref) {
          path = ref[color];
          path.smooth();
        }
      };

      Vectorizer.prototype.drawSpiralMultipleStrokes = function() {
        var color, count, i, l, len, len1, n, o, offset, path, position, raster, ref, ref1, ref2, rot, step, value, vector;
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        this.paths = [];
        for (i = l = 1, ref = this.data.nStrokes; 1 <= ref ? l <= ref : l >= ref; i = 1 <= ref ? ++l : --l) {
          path = this.addPath(new P.Path());
          path.strokeColor = this.data.strokeColor;
          path.strokeWidth = this.data.strokeWidth;
          path.closed = false;
          this.paths.push(path);
        }
        position = this.rectangle.center;
        count = 0;
        while (this.rectangle.center.subtract(position).length < this.rectangle.width / 2) {
          vector = new P.Point({
            angle: count * 5,
            length: count / 100
          });
          rot = vector.rotate(90);
          offset = rot.clone();
          offset.length = 1;
          color = raster.getAverageColor(position.add(vector.divide(2)));
          value = color ? (1 - color.gray) * this.data.spiralWidth / 2.5 : 0;
          rot.length = Math.max(value, 0.1);
          offset = -1;
          step = 2 / this.paths.length;
          ref1 = this.paths;
          for (n = 0, len = ref1.length; n < len; n++) {
            path = ref1[n];
            path.add(position.add(vector).add(rot.multiply(offset)));
            offset += step;
          }
          position = position.add(vector);
          count++;
        }
        ref2 = this.paths;
        for (o = 0, len1 = ref2.length; o < len1; o++) {
          path = ref2[o];
          path.smooth();
        }
      };

      Vectorizer.prototype.colorToCMYK = function(color) {
        var b, g, k, r, result;
        r = color.r;
        g = color.g;
        b = color.b;
        k = Math.min(1 - r, 1 - g, 1 - b);
        result = {
          c: (1 - r - k) / (1 - k) || 0,
          m: (1 - g - k) / (1 - k) || 0,
          y: (1 - b - k) / (1 - k) || 0,
          k: k
        };
        return result;
      };

      Vectorizer.prototype.drawCMYKstripes = function() {
        var angle, c, center, color, colors, colorsTo, colorsToNames, cymk, delta, deltaX, deltaY, i, j, l, len, maxSize, n, o, path, pixel, position, previousColor, raster, ref, ref1, square, startPosition, stripeGroup, stripeGroups;
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        maxSize = Math.max(raster["with"], raster.height);
        square = new P.Rectangle(maxSize, maxSize);
        pixel = new P.Rectangle(this.data.pixelSize, this.data.pixelSize);
        colorsToNames = {
          c: 'cyan',
          m: 'magenta',
          y: 'yellow',
          k: 'black'
        };
        colorsTo = {
          c: 15,
          m: 75,
          y: 0,
          k: 45
        };
        colors = [k, m, c, y];
        stripeGroups = new P.Group();
        for (l = 0, len = colors.length; l < len; l++) {
          c = colors[l];
          stripeGroup = new P.Group();
          angle = colorsToAngle[c];
          position = this.rectangle.topLeft;
          center = this.rectangle.center;
          position = position.rotate(angle, center);
          delta = new P.Point(this.data.pixelSize, 0);
          deltaX = delta.rotate(angle);
          deltaY = deltaX.rotate(-90);
          previousColor = null;
          path = null;
          for (i = n = 0, ref = this.data.nStripes; 0 <= ref ? n <= ref : n >= ref; i = 0 <= ref ? ++n : --n) {
            startPosition = position.clone();
            for (j = o = 0, ref1 = nSteps; 0 <= ref1 ? o <= ref1 : o >= ref1; j = 0 <= ref1 ? ++o : --o) {
              color = raster.getAverageColor(position, pixel);
              cymk = this.drawCMYKstripes(color);
              if (cymk[c] > 0.5) {
                if (path == null) {
                  path = new P.Path();
                  path.strokeColor = colorsToNames[c];
                  path.strokeWidth = this.data.pixelSize;
                  stripeGroup.addChild(path);
                }
                path.add(position);
              } else if (path != null) {
                path = null;
              }
              position = position.add(deltaX);
            }
            position = startPosition.add(deltaY);
          }
          stripeGroups.addChild(stripeGroup);
        }
      };

      Vectorizer.prototype.createShape = function() {
        Vectorizer.__super__.createShape.call(this);
        this.allRastersLoaded();
      };

      return Vectorizer;

    })(Shape);
    return Vectorizer;
  });

}).call(this);
