// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['Items/Paths/Shapes/Shape', 'UI/Modal'], function(Shape, Modal) {
    var Vectorizer;
    Vectorizer = (function(_super) {
      __extends(Vectorizer, _super);

      function Vectorizer() {
        this.allRastersLoaded = __bind(this.allRastersLoaded, this);
        return Vectorizer.__super__.constructor.apply(this, arguments);
      }

      Vectorizer.Shape = P.Path.Rectangle;

      Vectorizer.label = 'Vectorizer';

      Vectorizer.description = "Creates a vectorized version of an image.";

      Vectorizer.squareByDefault = true;

      Vectorizer.initializeParameters = function() {
        var parameters;
        parameters = Vectorizer.__super__.constructor.initializeParameters.call(this);
        parameters['Style'].strokeWidth["default"] = 1;
        parameters['Style'].strokeColor["default"] = 'black';
        parameters['Style'].strokeColor.defaultFunction = null;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].effectType = {
          "default": 'multipleStrokes',
          values: ['multipleStrokes', 'color', 'blackAndWhite'],
          label: 'Effect type'
        };
        parameters['Parameters'].nStrokes = {
          type: 'slider',
          label: 'StrokeNumber',
          min: 2,
          max: 16,
          "default": 4
        };
        parameters['Parameters'].spiralWidth = {
          type: 'slider',
          label: 'Spiral width',
          min: 1,
          max: 16,
          "default": 7
        };
        return parameters;
      };

      Vectorizer.parameters = Vectorizer.initializeParameters();

      Vectorizer.createTool(Vectorizer);

      Vectorizer.prototype.initialize = function() {
        var modal;
        if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
          console.log('File upload not supported');
          R.alertManager.alert('File upload not supported', 'error');
          return;
        }
        modal = Modal.createModal({
          title: 'Select an image',
          submit: function() {}
        });
        modal.addImageSelector({
          name: "image-selector",
          rastersLoadedCallback: this.allRastersLoaded,
          extractor: (function(_this) {
            return function() {
              return _this.rasters.length > 0;
            };
          })(this)
        });
        modal.show();
      };

      Vectorizer.prototype.allRastersLoaded = function(rasters) {
        var file, raster;
        if (((this.rasters == null) || this.rasters.length === 0) && (rasters == null)) {
          return;
        }
        if (this.rasters == null) {
          this.rasters = [];
          for (file in rasters) {
            raster = rasters[file];
            this.rasters.push(raster);
          }
        }
        switch (this.data.effectType) {
          case 'multipleStrokes':
            this.drawSpiralMultipleStrokes();
            break;
          case 'color':
            this.drawSpiralColor();
            break;
          case 'blackAndWhite':
            this.drawSpiralColor(true);
        }
      };

      Vectorizer.prototype.drawSpiralColor = function(blackAndWhite) {
        var c, color, colors, count, offset, offsets, path, position, raster, rot, v, value, vector, _i, _j, _len, _len1, _ref;
        if (blackAndWhite == null) {
          blackAndWhite = false;
        }
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        colors = blackAndWhite ? ['black'] : ['red', 'green', 'blue'];
        offsets = blackAndWhite ? {
          'black': 0
        } : {
          'red': -3.7 / 1.5,
          'green': 0,
          'blue': 3.7 / 1.5
        };
        this.paths = {};
        for (_i = 0, _len = colors.length; _i < _len; _i++) {
          color = colors[_i];
          path = this.addPath(new P.Path());
          path.fillColor = color;
          path.strokeColor = null;
          path.strokeWidth = 0;
          path.closed = true;
          this.paths[color] = path;
        }
        position = this.rectangle.center;
        count = 0;
        while (this.rectangle.center.subtract(position).length < this.rectangle.width / 2) {
          vector = new P.Point({
            angle: count * 5,
            length: count / 100
          });
          rot = vector.rotate(90);
          offset = rot.clone();
          offset.length = 1;
          color = raster.getAverageColor(position.add(vector.divide(2)));
          for (_j = 0, _len1 = colors.length; _j < _len1; _j++) {
            c = colors[_j];
            v = blackAndWhite ? color.gray : color[c];
            value = color ? (1 - v) * this.data.spiralWidth / 2.5 : 0;
            rot.length = Math.max(value, 0.1);
            this.paths[c].add(position.add(vector).add(offset.multiply(offsets[c])).subtract(rot));
            this.paths[c].insert(0, position.add(vector).add(offset.multiply(offsets[c])).add(rot));
          }
          position = position.add(vector);
          count++;
        }
        _ref = this.paths;
        for (color in _ref) {
          path = _ref[color];
          path.smooth();
        }
      };

      Vectorizer.prototype.drawSpiralMultipleStrokes = function() {
        var color, count, i, offset, path, position, raster, rot, step, value, vector, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        this.paths = [];
        for (i = _i = 1, _ref = this.data.nStrokes; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          path = this.addPath(new P.Path());
          path.strokeColor = this.data.strokeColor;
          path.strokeWidth = this.data.strokeWidth;
          path.closed = false;
          this.paths.push(path);
        }
        position = this.rectangle.center;
        count = 0;
        while (this.rectangle.center.subtract(position).length < this.rectangle.width / 2) {
          vector = new P.Point({
            angle: count * 5,
            length: count / 100
          });
          rot = vector.rotate(90);
          offset = rot.clone();
          offset.length = 1;
          color = raster.getAverageColor(position.add(vector.divide(2)));
          value = color ? (1 - color.gray) * this.data.spiralWidth / 2.5 : 0;
          rot.length = Math.max(value, 0.1);
          offset = -1;
          step = 2 / this.paths.length;
          _ref1 = this.paths;
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            path = _ref1[_j];
            path.add(position.add(vector).add(rot.multiply(offset)));
            offset += step;
          }
          position = position.add(vector);
          count++;
        }
        _ref2 = this.paths;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          path = _ref2[_k];
          path.smooth();
        }
      };

      Vectorizer.prototype.createShape = function() {
        Vectorizer.__super__.createShape.call(this);
        this.allRastersLoaded();
      };

      return Vectorizer;

    })(Shape);
    return Vectorizer;
  });

}).call(this);
