// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['utils', 'SpeedPath'], function(utils, SpeedPath) {
    var GridPath;
    GridPath = (function(_super) {
      __extends(GridPath, _super);

      function GridPath() {
        return GridPath.__super__.constructor.apply(this, arguments);
      }

      GridPath.label = 'Grid path';

      GridPath.rdescription = "Draws a grid along the path, the thickness of the grid being function of the speed of the drawing.";

      GridPath.initializeParameters = function() {
        var parameters;
        parameters = GridPath.__super__.constructor.initializeParameters.call(this);
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].step = {
          type: 'slider',
          label: 'Step',
          min: 5,
          max: 100,
          "default": 5,
          simplified: 20,
          step: 1
        };
        parameters['Parameters'].minWidth = {
          type: 'slider',
          label: 'Min width',
          min: 1,
          max: 100,
          "default": 5
        };
        parameters['Parameters'].maxWidth = {
          type: 'slider',
          label: 'Max width',
          min: 1,
          max: 250,
          "default": 200
        };
        parameters['Parameters'].minSpeed = {
          type: 'slider',
          label: 'Min speed',
          min: 1,
          max: 250,
          "default": 1
        };
        parameters['Parameters'].maxSpeed = {
          type: 'slider',
          label: 'Max speed',
          min: 1,
          max: 250,
          "default": 200
        };
        parameters['Parameters'].nLines = {
          type: 'slider',
          label: 'N lines',
          min: 1,
          max: 5,
          "default": 2,
          simplified: 2,
          step: 1
        };
        parameters['Parameters'].symmetric = {
          type: 'dropdown',
          label: 'Symmetry',
          values: ['symmetric', 'top', 'bottom'],
          "default": 'top'
        };
        parameters['Parameters'].speedForWidth = {
          type: 'checkbox',
          label: 'Speed for width',
          "default": true
        };
        parameters['Parameters'].speedForLength = {
          type: 'checkbox',
          label: 'Speed for length',
          "default": false
        };
        parameters['Parameters'].orthoLines = {
          type: 'checkbox',
          label: 'Orthogonal lines',
          "default": true
        };
        parameters['Parameters'].lengthLines = {
          type: 'checkbox',
          label: 'Length lines',
          "default": true
        };
        return parameters;
      };

      GridPath.parameters = GridPath.initializeParameters();

      GridPath.createTool(GridPath);

      GridPath.prototype.beginDraw = function() {
        var i, nLines, _i;
        this.initializeDrawing(false);
        if (this.data.lengthLines) {
          this.lines = [];
          nLines = this.data.nLines;
          if (this.data.symmetric === 'symmetric') {
            nLines *= 2;
          }
          for (i = _i = 1; 1 <= nLines ? _i <= nLines : _i >= nLines; i = 1 <= nLines ? ++_i : --_i) {
            this.lines.push(this.addPath());
          }
        }
        this.lastOffset = 0;
      };

      GridPath.prototype.updateDraw = function(offset, step) {
        var addPoint, midOffset, speed, stepOffset;
        if (!step) {
          return;
        }
        speed = this.speedAt(offset);
        addPoint = (function(_this) {
          return function(offset, speed) {
            var delta, divisor, i, line, normal, path, point, width, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
            point = _this.controlPath.getPointAt(offset);
            normal = _this.controlPath.getNormalAt(offset).normalize();
            if (_this.data.speedForWidth) {
              width = _this.data.minWidth + (_this.data.maxWidth - _this.data.minWidth) * speed / _this.constructor.maxSpeed;
            } else {
              width = _this.data.minWidth;
            }
            if (_this.data.lengthLines) {
              divisor = _this.data.nLines > 1 ? _this.data.nLines - 1 : 1;
              if (_this.data.symmetric === 'symmetric') {
                _ref = _this.lines;
                for (i = _i = 0, _len = _ref.length; _i < _len; i = _i += 2) {
                  line = _ref[i];
                  _this.lines[i + 0].add(point.add(normal.multiply(i * width * 0.5 / divisor)));
                  _this.lines[i + 1].add(point.add(normal.multiply(-i * width * 0.5 / divisor)));
                }
              } else {
                if (_this.data.symmetric === 'top') {
                  _ref1 = _this.lines;
                  for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                    line = _ref1[i];
                    line.add(point.add(normal.multiply(i * width / divisor)));
                  }
                } else if (_this.data.symmetric === 'bottom') {
                  _ref2 = _this.lines;
                  for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
                    line = _ref2[i];
                    line.add(point.add(normal.multiply(-i * width / divisor)));
                  }
                }
              }
            }
            if (_this.data.orthoLines) {
              path = _this.addPath();
              delta = normal.multiply(width);
              switch (_this.data.symmetric) {
                case 'symmetric':
                  path.add(point.add(delta));
                  path.add(point.subtract(delta));
                  break;
                case 'top':
                  path.add(point.add(delta));
                  path.add(point);
                  break;
                case 'bottom':
                  path.add(point.subtract(delta));
                  path.add(point);
              }
            }
          };
        })(this);
        if (!this.data.speedForLength) {
          addPoint(offset, speed);
        } else {
          speed = this.data.minSpeed + (speed / this.constructor.maxSpeed) * (this.data.maxSpeed - this.data.minSpeed);
          stepOffset = offset - this.lastOffset;
          if (stepOffset > speed) {
            midOffset = (offset + this.lastOffset) / 2;
            addPoint(midOffset, speed);
            this.lastOffset = offset;
          }
        }
      };

      GridPath.prototype.endDraw = function() {};

      return GridPath;

    })(SpeedPath);
    return GridPath;
  });

}).call(this);

//# sourceMappingURL=GridPath.map
