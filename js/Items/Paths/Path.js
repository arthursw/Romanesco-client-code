// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['Items/Content', 'Tools/PathTool'], function(Content, PathTool) {
    var Path;
    Path = (function(_super) {
      __extends(Path, _super);

      Path.label = 'Pen';

      Path.description = "The classic and basic pen tool";

      Path.cursor = {
        position: {
          x: 0,
          y: 0
        },
        name: 'crosshair'
      };

      Path.constructor.secureDistance = 2;

      Path.initializeParameters = function() {
        var parameters;
        return parameters = {
          'Items': {
            align: R.parameters.align,
            distribute: R.parameters.distribute,
            duplicate: R.parameters.duplicate,
            "delete": R.parameters["delete"],
            editTool: {
              type: 'button',
              label: 'Edit tool',
              "default": (function(_this) {
                return function() {
                  return R.codeEditor.setSource(_this.source);
                };
              })(this)
            }
          },
          'Style': {
            strokeWidth: $.extend(true, {}, R.parameters.strokeWidth),
            strokeColor: $.extend(true, {}, R.parameters.strokeColor),
            fillColor: $.extend(true, {}, R.parameters.fillColor)
          },
          'Shadow': {
            folderIsClosedByDefault: true,
            shadowOffsetX: {
              type: 'slider',
              label: 'Shadow offset x',
              min: -25,
              max: 25,
              "default": 0
            },
            shadowOffsetY: {
              type: 'slider',
              label: 'Shadow offset y',
              min: -25,
              max: 25,
              "default": 0
            },
            shadowBlur: {
              type: 'slider',
              label: 'Shadow blur',
              min: 0,
              max: 50,
              "default": 0
            },
            shadowColor: {
              type: 'color',
              label: 'Shadow color',
              "default": '#000',
              defaultCheck: false
            }
          }
        };
      };

      Path.parameters = Path.initializeParameters();

      Path.createTool = function(Path) {
        new R.Tools.Path(Path);
      };

      Path.create = function(duplicateData) {
        var copy;
        if (duplicateData == null) {
          duplicateData = this.getDuplicateData();
        }
        copy = new this(duplicateData.date, duplicateData.data, null, duplicateData.points);
        copy.draw();
        if (!this.socketAction) {
          copy.save(false);
          R.socket.emit("bounce", {
            itemClass: this.name,
            "function": "create",
            "arguments": [duplicateData]
          });
        }
        return copy;
      };

      function Path(date, data, pk, points, lock) {
        this.date = date != null ? date : null;
        this.data = data != null ? data : null;
        this.pk = pk != null ? pk : null;
        if (points == null) {
          points = null;
        }
        this.lock = lock != null ? lock : null;
        this.update = __bind(this.update, this);
        this.saveCallback = __bind(this.saveCallback, this);
        if (!this.lock) {
          Path.__super__.constructor.call(this, this.data, this.pk, this.date, R.sidebar.pathListJ, R.sortedPaths);
        } else {
          Path.__super__.constructor.call(this, this.data, this.pk, this.date, this.lock.itemListsJ.find('.rPath-list'), this.lock.sortedPaths);
        }
        this.selectionHighlight = null;
        if (points != null) {
          this.loadPath(points);
        }
        return;
      }

      Path.prototype.getDuplicateData = function() {
        var data;
        data = Path.__super__.getDuplicateData.call(this);
        data.points = this.pathOnPlanet();
        data.date = this.date;
        return data;
      };

      Path.prototype.getDrawingBounds = function() {
        if (!this.canvasRaster && (this.drawing != null) && this.drawing.strokeBounds.area > 0) {
          if (this.raster != null) {
            return this.raster.bounds;
          }
          return this.drawing.strokeBounds;
        }
        return this.getBounds().expand(this.data.strokeWidth);
      };

      Path.prototype.endSetRectangle = function() {
        Path.__super__.endSetRectangle.call(this);
        this.draw();
        this.rasterize();
      };

      Path.prototype.setRectangle = function(rectangle, update) {
        Path.__super__.setRectangle.call(this, rectangle, update);
        this.draw(update);
      };

      Path.prototype.setRotation = function(rotation, center, update) {
        Path.__super__.setRotation.call(this, rotation, center, update);
        this.draw(update);
      };

      Path.prototype.projectToRaster = function(point) {
        return point.subtract(this.canvasRaster.bounds.topLeft);
      };

      Path.prototype.prepareHitTest = function(fullySelected, strokeWidth) {
        var _ref;
        Path.__super__.prepareHitTest.call(this);
        this.stateBeforeHitTest = {};
        this.stateBeforeHitTest.groupWasVisible = this.group.visible;
        this.stateBeforeHitTest.controlPathWasVisible = this.controlPath.visible;
        this.stateBeforeHitTest.controlPathWasSelected = this.controlPath.selected;
        this.stateBeforeHitTest.controlPathWasFullySelected = this.controlPath.fullySelected;
        this.stateBeforeHitTest.controlPathStrokeWidth = this.controlPath.strokeWidth;
        this.group.visible = true;
        this.controlPath.visible = true;
        this.controlPath.selected = true;
        if (strokeWidth) {
          this.controlPath.strokeWidth = strokeWidth;
        }
        if (fullySelected) {
          this.controlPath.fullySelected = true;
        }
        if ((_ref = this.speedGroup) != null) {
          _ref.selected = true;
        }
      };

      Path.prototype.finishHitTest = function(fullySelected) {
        var _ref;
        if (fullySelected == null) {
          fullySelected = true;
        }
        Path.__super__.finishHitTest.call(this, fullySelected);
        this.group.visible = this.stateBeforeHitTest.groupWasVisible;
        this.controlPath.visible = this.stateBeforeHitTest.controlPathWasVisible;
        this.controlPath.strokeWidth = this.stateBeforeHitTest.controlPathStrokeWidth;
        this.controlPath.fullySelected = this.stateBeforeHitTest.controlPathWasFullySelected;
        if (!this.controlPath.fullySelected) {
          this.controlPath.selected = this.stateBeforeHitTest.controlPathWasSelected;
        }
        this.stateBeforeHitTest = null;
        if ((_ref = this.speedGroup) != null) {
          _ref.selected = false;
        }
      };

      Path.prototype.hitTest = function(event) {
        var hitResult, wasSelected;
        wasSelected = this.selected;
        hitResult = Path.__super__.hitTest.call(this, event);
        if (hitResult == null) {
          return;
        }
        if (hitResult.type === 'stroke' || !wasSelected) {
          hitResult.type = 'stroke';
          if (R.tools.select.selectionRectangle != null) {
            R.tools.select.selectionRectangle.beginAction(hitResult);
          } else {
            $(R.tools.select).one('selectionRectangleUpdated', function() {
              return R.tools.select.selectionRectangle.beginAction(hitResult);
            });
          }
        }
        return hitResult;
      };

      Path.prototype.select = function() {
        if (!Path.__super__.select.call(this) || (this.controlPath == null)) {
          return false;
        }
        return true;
      };

      Path.prototype.deselect = function() {
        if (!Path.__super__.deselect.call(this)) {
          return false;
        }
        return true;
      };

      Path.prototype.updateSelect = function(event) {
        Path.__super__.updateSelect.call(this, event);
      };

      Path.prototype.doubleClick = function(event) {};

      Path.prototype.loadPath = function(points) {};

      Path.prototype.setParameter = function(name, value, updateGUI, update) {
        Path.__super__.setParameter.call(this, name, value, updateGUI, update);
        if (this.previousBoundingBox == null) {
          this.previousBoundingBox = this.getDrawingBounds();
        }
        this.draw();
      };

      Path.prototype.applyStylesToPath = function(path) {
        path.strokeColor = this.data.strokeColor;
        path.strokeWidth = this.data.strokeWidth;
        path.fillColor = this.data.fillColor;
        if (this.data.shadowOffsetY != null) {
          path.shadowOffset = new P.Point(this.data.shadowOffsetX, this.data.shadowOffsetY);
        }
        if (this.data.shadowBlur != null) {
          path.shadowBlur = this.data.shadowBlur;
        }
        if (this.data.shadowColor != null) {
          path.shadowColor = this.data.shadowColor;
        }
      };

      Path.prototype.addPath = function(path, applyStyles) {
        if (applyStyles == null) {
          applyStyles = true;
        }
        if (path == null) {
          path = new P.Path();
        }
        path.controller = this;
        if (applyStyles) {
          this.applyStylesToPath(path);
        }
        this.drawing.addChild(path);
        return path;
      };

      Path.prototype.addControlPath = function(controlPath) {
        this.controlPath = controlPath;
        if (this.lock) {
          this.lock.group.addChild(this.group);
        }
        if (this.controlPath == null) {
          this.controlPath = new P.Path();
        }
        this.group.addChild(this.controlPath);
        this.controlPath.name = "controlPath";
        this.controlPath.controller = this;
        this.controlPath.strokeWidth = 10;
        this.controlPath.strokeColor = R.selectionBlue;
        this.controlPath.strokeColor.alpha = 0.25;
        this.controlPath.strokeCap = 'round';
        this.controlPath.visible = false;
      };

      Path.prototype.initializeDrawing = function(createCanvas) {
        var bounds, canvas, position, _ref, _ref1, _ref2;
        if (createCanvas == null) {
          createCanvas = false;
        }
        if ((_ref = this.raster) != null) {
          _ref.remove();
        }
        this.raster = null;
        this.controlPath.strokeWidth = 10;
        if ((_ref1 = this.drawing) != null) {
          _ref1.remove();
        }
        this.drawing = new P.Group();
        this.drawing.name = "drawing";
        this.drawing.strokeColor = this.data.strokeColor;
        this.drawing.strokeWidth = this.data.strokeWidth;
        this.drawing.fillColor = this.data.fillColor;
        this.drawing.insertBelow(this.controlPath);
        this.drawing.controlPath = this.controlPath;
        this.drawing.controller = this;
        this.group.addChild(this.drawing);
        if (createCanvas) {
          canvas = document.createElement("canvas");
          if (this.rectangle.area < 2) {
            canvas.width = P.view.size.width;
            canvas.height = P.view.size.height;
            position = P.view.center;
          } else {
            bounds = this.getDrawingBounds();
            canvas.width = bounds.width;
            canvas.height = bounds.height;
            position = bounds.center;
          }
          if ((_ref2 = this.canvasRaster) != null) {
            _ref2.remove();
          }
          this.canvasRaster = new P.Raster(canvas, position);
          this.drawing.addChild(this.canvasRaster);
          this.context = this.canvasRaster.canvas.getContext("2d");
          this.context.strokeStyle = this.data.strokeColor;
          this.context.fillStyle = this.data.fillColor;
          this.context.lineWidth = this.data.strokeWidth;
        }
      };

      Path.prototype.setAnimated = function(animated) {
        if (animated) {
          Utils.Animation.registerAnimation(this);
        } else {
          Utils.Animation.deregisterAnimation(this);
        }
      };

      Path.prototype.draw = function(simplified) {
        if (simplified == null) {
          simplified = false;
        }
      };

      Path.prototype.initialize = function() {};

      Path.prototype.beginCreate = function(point, event) {};

      Path.prototype.updateCreate = function(point, event) {};

      Path.prototype.endCreate = function(point, event) {};

      Path.prototype.insertAbove = function(path, index, update) {
        if (index == null) {
          index = null;
        }
        if (update == null) {
          update = false;
        }
        this.zindex = this.group.index;
        Path.__super__.insertAbove.call(this, path, index, update);
      };

      Path.prototype.insertBelow = function(path, index, update) {
        if (index == null) {
          index = null;
        }
        if (update == null) {
          update = false;
        }
        this.zindex = this.group.index;
        Path.__super__.insertBelow.call(this, path, index, update);
      };

      Path.prototype.getData = function() {
        return this.data;
      };

      Path.prototype.getStringifiedData = function() {
        return JSON.stringify(this.getData());
      };

      Path.prototype.getPlanet = function() {
        return Utils.CS.projectToPlanet(this.controlPath.segments[0].point);
      };

      Path.prototype.save = function(addCreateCommand) {
        var args;
        if (addCreateCommand == null) {
          addCreateCommand = true;
        }
        if (this.controlPath == null) {
          return;
        }
        R.paths[this.pk != null ? this.pk : this.id] = this;
        args = {
          city: R.city,
          box: Utils.CS.boxFromRectangle(this.getDrawingBounds()),
          points: this.pathOnPlanet(),
          data: this.getStringifiedData(),
          date: this.date,
          object_type: this.constructor.label
        };
        Dajaxice.draw.savePath(this.saveCallback, args);
        Path.__super__.save.apply(this, arguments);
      };

      Path.prototype.saveCallback = function(result) {
        R.loader.checkError(result);
        if (result.pk == null) {
          return;
        }
        this.setPK(result.pk);
        if (this.updateAfterSave != null) {
          this.update(this.updateAfterSave);
        }
        Path.__super__.saveCallback.apply(this, arguments);
      };

      Path.prototype.getUpdateFunction = function() {
        return 'updatePath';
      };

      Path.prototype.getUpdateArguments = function(type) {
        var args;
        switch (type) {
          case 'z-index':
            args = {
              pk: this.pk,
              date: this.date
            };
            break;
          default:
            args = {
              pk: this.pk,
              points: this.pathOnPlanet(),
              data: this.getStringifiedData(),
              box: Utils.CS.boxFromRectangle(this.getDrawingBounds())
            };
        }
        return args;
      };

      Path.prototype.update = function(type) {
        if (this.pk == null) {
          this.updateAfterSave = type;
          return;
        }
        delete this.updateAfterSave;
        Dajaxice.draw.updatePath(this.updatePathCallback, this.getUpdateArguments(type));
      };

      Path.prototype.updatePathCallback = function(result) {
        R.loader.checkError(result);
      };

      Path.prototype.setPK = function(pk) {
        Path.__super__.setPK.apply(this, arguments);
        R.paths[pk] = this;
        delete R.paths[this.id];
      };

      Path.prototype.remove = function() {
        if (!this.group) {
          return;
        }
        Utils.Animation.deregisterAnimation();
        this.controlPath = null;
        this.drawing = null;
        if (this.raster == null) {
          this.raster = null;
        }
        if (this.canvasRaster == null) {
          this.canvasRaster = null;
        }
        if (this.pk != null) {
          delete R.paths[this.pk];
        } else {
          delete R.paths[this.id];
        }
        Path.__super__.remove.call(this);
      };

      Path.prototype.deleteFromDatabase = function() {
        Dajaxice.draw.deletePath(R.loader.checkError, {
          pk: this.pk
        });
      };

      Path.prototype.pathOnPlanet = function(controlSegments) {
        var p, planet, points, segment, _i, _len;
        if (controlSegments == null) {
          controlSegments = this.controlPath.segments;
        }
        points = [];
        planet = this.getPlanet();
        for (_i = 0, _len = controlSegments.length; _i < _len; _i++) {
          segment = controlSegments[_i];
          p = Utils.CS.projectToPosOnPlanet(segment.point, planet);
          points.push(Utils.CS.pointToArray(p));
        }
        return points;
      };

      return Path;

    })(Content);
    return Path;
  });

}).call(this);
