// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define([], function() {
    var ScreenshotRectangle, SelectionRectangle, SelectionRotationRectangle;
    SelectionRectangle = (function() {
      SelectionRectangle.indexToName = {
        0: 'bottomLeft',
        1: 'left',
        2: 'topLeft',
        3: 'top',
        4: 'topRight',
        5: 'right',
        6: 'bottomRight',
        7: 'bottom'
      };

      SelectionRectangle.oppositeName = {
        'top': 'bottom',
        'bottom': 'top',
        'left': 'right',
        'right': 'left',
        'topLeft': 'bottomRight',
        'topRight': 'bottomLeft',
        'bottomRight': 'topLeft',
        'bottomLeft': 'topRight'
      };

      SelectionRectangle.cornersNames = ['topLeft', 'topRight', 'bottomRight', 'bottomLeft'];

      SelectionRectangle.sidesNames = ['left', 'right', 'top', 'bottom'];

      SelectionRectangle.valueFromName = function(point, name) {
        switch (name) {
          case 'left':
          case 'right':
            return point.x;
          case 'top':
          case 'bottom':
            return point.y;
          default:
            return point;
        }
      };

      SelectionRectangle.pointFromName = function(rectangle, name) {
        switch (name) {
          case 'left':
          case 'right':
            return new Point(rectangle[name], rectangle.center.y);
          case 'top':
          case 'bottom':
            return new Point(rectangle.center.x, rectangle[name]);
          default:
            return rectangle[name];
        }
      };

      SelectionRectangle.hitOptions = {
        segments: true,
        stroke: true,
        fill: true,
        selected: true,
        tolerance: 5
      };

      function SelectionRectangle(items) {
        this.items = items;
        this.rectangle = this.getBoundingRectangle(this.items);
        this.transformState = null;
        this.group = new P.Group();
        this.group.name = "selection rectangle group";
        this.path = new P.Path.Rectangle(this.rectangle);
        this.path.name = "selection rectangle path";
        this.path.strokeColor = R.selectionBlue;
        this.path.strokeWidth = 1;
        this.path.selected = true;
        this.path.controller = this;
        this.group.addChild(this.path);
        this.addHandles(this.rectangle);
        this.path.pivot = this.rectangle.center;
        return;
      }

      SelectionRectangle.prototype.getBoundingRectangle = function(items) {
        var bounds, item, _i, _len;
        bounds = items[0].getBounds();
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          bounds = bounds.unite(item.getBounds());
        }
        return bounds;
      };

      SelectionRectangle.prototype.addHandles = function(bounds) {
        this.path.insert(1, new P.Point(bounds.left, bounds.center.y));
        this.path.insert(3, new P.Point(bounds.center.x, bounds.top));
        this.path.insert(5, new P.Point(bounds.right, bounds.center.y));
        this.path.insert(7, new P.Point(bounds.center.x, bounds.bottom));
      };

      SelectionRectangle.prototype.getClosestCorner = function(point) {
        var closestCorner, cornerName, distance, minDistance, _i, _len, _ref;
        minDistance = Infinity;
        closestCorner = '';
        _ref = this.constructor.cornersNames;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cornerName = _ref[_i];
          distance = this.rectangle[cornerName].getDistance(point, true);
          if (distance < minDistance) {
            closestCorner = cornerName;
            minDistance = distance;
          }
        }
        return closestCorner;
      };

      SelectionRectangle.prototype.setTransformState = function(hitResult) {
        switch (hitResult.type) {
          case 'stroke':
            this.transformState = {
              command: 'Move',
              corner: this.getClosestCorner(hitResult.point)
            };
            break;
          case 'segment':
            this.transformState = {
              command: 'Resize',
              index: hitResult.segment.index
            };
            break;
          default:
            this.transformState = {
              command: 'Move'
            };
        }
      };

      SelectionRectangle.prototype.hitTest = function(event) {
        var hitResult;
        hitResult = this.path.hitTest(event.point, this.constructor.hitOptions);
        if (hitResult == null) {
          return;
        }
        this.setTransformState(hitResult);
        return this.transformState;
      };

      SelectionRectangle.prototype.translate = function(delta) {
        var item, _i, _len, _ref;
        this.translation = this.translation.add(delta);
        this.path.translate(delta);
        _ref = this.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          item.translate(delta);
        }
      };

      SelectionRectangle.prototype.snapPosition = function(event) {
        var destination;
        if (this.dragOffset == null) {
          this.dragOffset = this.rectangle.center.subtract(event.downPoint);
        }
        destination = Utils.Event.snap2D(event.point.add(this.dragOffset));
        this.translate(destination.subtract(this.rectangle.center));
      };

      SelectionRectangle.prototype.snapEdgePosition = function(event) {
        var cornerName, destination, rectangle;
        cornerName = this.transformState.corner;
        rectangle = this.rectangle.clone();
        if (this.dragOffset == null) {
          this.dragOffset = rectangle[cornerName].subtract(event.downPoint);
        }
        destination = Utils.Event.snap2D(event.point.add(this.dragOffset));
        rectangle.moveCorner(cornerName, destination);
        this.translate(rectangle.center.subtract(this.rectangle.center));
      };

      SelectionRectangle.prototype.beginTranslate = function(event) {
        this.translation = new Point();
      };

      SelectionRectangle.prototype.updateTranslate = function(event) {
        if (Utils.Event.getSnap() <= 1) {
          this.translate(event.delta);
        } else {
          if (this.selectionState.corner != null) {
            this.snapEdgePosition(event);
          } else {
            this.snapPosition(event);
          }
        }
      };

      SelectionRectangle.prototype.endTranslate = function() {
        this.dragOffset = null;
        return this.translation;
      };

      SelectionRectangle.prototype.getScale = function(event) {
        return event.point.subtract(this.rectangle.center);
      };

      SelectionRectangle.prototype.keepAspectRatio = function(event, scale) {
        if (!event.modifiers.shift && __indexOf.call(this.constructor.cornersNames, name) >= 0 && this.rectangle.width > 0 && this.rectangle.height > 0) {
          if (Math.abs(scale.x / this.rectangle.width) > Math.abs(scale.y / this.rectangle.height)) {
            scale.x = Utils.sign(scale.x) * Math.abs(this.rectangle.width * scale.y / this.rectangle.height);
          } else {
            scale.y = Utils.sign(scale.y) * Math.abs(this.rectangle.height * scale.x / this.rectangle.width);
          }
        }
      };

      SelectionRectangle.prototype.getScaleCenter = function() {
        var name;
        if (R.specialKey(event)) {
          name = this.constructor.indexToName[this.selectionState.index];
          return this.constructor.pointFromName(this.rectangle, this.constructor.oppositeName[name]);
        } else {
          return this.rectangle.center;
        }
      };

      SelectionRectangle.prototype.normalizeScale = function(scale) {
        scale.x = Math.abs(2 * scale.x / rectangle.width);
        scale.y = Math.abs(2 * scale.y / rectangle.height);
      };

      SelectionRectangle.prototype.scale = function(scale, center) {
        var item, _i, _len, _ref;
        this.scaling = this.scaling.add(scale);
        this.rectangle.scaleFromCenter(scale, center);
        this.path.scale(scale.x, scale.y, center);
        _ref = this.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          item.scale(scale, center);
        }
      };

      SelectionRectangle.prototype.beginScale = function(event) {
        this.scaling = new Point(1, 1);
      };

      SelectionRectangle.prototype.updateScale = function(event) {
        var center, scale;
        event.point = Utils.Event.snap2D(event.point);
        scale = this.getScale(event);
        this.keepAspectRatio(event, scale);
        this.normalizeScale(scale);
        center = this.getScaleCenter(event);
        this.scale(scale, center);
      };

      SelectionRectangle.prototype.endScale = function() {
        return [this.scaling, this.rectangle.center];
      };

      return SelectionRectangle;

    })();
    SelectionRotationRectangle = (function(_super) {
      __extends(SelectionRotationRectangle, _super);

      SelectionRotationRectangle.indexToName = {
        0: 'bottomLeft',
        1: 'left',
        2: 'topLeft',
        3: 'top',
        4: 'rotation-handle',
        5: 'top',
        6: 'topRight',
        7: 'right',
        8: 'bottomRight',
        9: 'bottom'
      };

      function SelectionRotationRectangle(rectangle) {
        SelectionRotationRectangle.__super__.constructor.call(this, rectangle);
        this.rotation = 0;
        return;
      }

      SelectionRotationRectangle.prototype.addHandles = function(bounds) {
        SelectionRotationRectangle.__super__.addHandles.call(this, bounds);
        this.path.insert(3, new P.Point(bounds.center.x, bounds.top - 25));
        this.path.insert(3, new P.Point(bounds.center.x, bounds.top));
      };

      SelectionRotationRectangle.prototype.setTransformState = function(hitResult) {
        if ((hitResult != null ? hitResult.type : void 0) === 'segment') {
          if (this.constructor.indexToName[hitResult.segment.index] === 'rotation-handle') {
            this.selectionState = {
              type: 'rotation'
            };
            return;
          }
        }
        SelectionRotationRectangle.__super__.setTransformState.call(this, hitResult);
      };

      SelectionRotationRectangle.prototype.getScale = function(event) {
        var delta, dx, dy, x, y;
        delta = SelectionRotationRectangle.__super__.getScale.call(this, event);
        x = new P.Point(1, 0);
        x.angle += this.rotation;
        dx = x.dot(delta);
        y = new P.Point(0, 1);
        y.angle += this.rotation;
        dy = y.dot(delta);
        return new Point(dx, dy);
      };

      SelectionRotationRectangle.prototype.rotate = function(angle) {
        var item, _i, _len, _ref;
        this.rotation += angle;
        this.path.rotate(angle);
        _ref = this.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          item.rotate(angle, rectangle.center);
        }
      };

      SelectionRotationRectangle.prototype.beginRotate = function() {
        this.rotation = 0;
      };

      SelectionRotationRectangle.prototype.updateRotate = function(event) {
        var angle;
        angle = event.point.subtract(this.rectangle.center).angle + 90;
        if (event.modifiers.shift || R.specialKey(event) || Utils.Event.getSnap() > 1) {
          angle = Utils.roundToMultiple(rotation, event.modifiers.shift ? 10 : 5);
        }
        this.rotate(angle - this.rotation);
      };

      SelectionRotationRectangle.prototype.endRotate = function() {
        return [this.rotation, this.rectangle.center];
      };

      return SelectionRotationRectangle;

    })(SelectionRectangle);
    ScreenshotRectangle = (function(_super) {
      __extends(ScreenshotRectangle, _super);

      function ScreenshotRectangle(rectangle, extractImage) {
        var separatorJ;
        this.rectangle = rectangle;
        ScreenshotRectangle.__super__.constructor.call(this);
        this.drawing = new P.Path.Rectangle(this.rectangle);
        this.drawing.name = 'selection rectangle background';
        this.drawing.strokeWidth = 1;
        this.drawing.strokeColor = R.selectionBlue;
        this.drawing.controller = this;
        this.group.addChild(this.drawing);
        separatorJ = R.stageJ.find(".text-separator");
        this.buttonJ = R.templatesJ.find(".screenshot-btn").clone().insertAfter(separatorJ);
        this.buttonJ.find('.extract-btn').click(function(event) {
          var redraw;
          redraw = $(this).attr('data-click') === 'redraw-snapshot';
          extractImage(redraw);
        });
        this.updateTransform();
        this.select();
        Tool.select.select();
        return;
      }

      ScreenshotRectangle.prototype.remove = function() {
        this.removing = true;
        ScreenshotRectangle.__super__.remove.call(this);
        this.buttonJ.remove();
        R.tools['Screenshot'].selectionRectangle = null;
      };

      ScreenshotRectangle.prototype.deselect = function() {
        if (!ScreenshotRectangle.__super__.deselect.call(this)) {
          return false;
        }
        if (!this.removing) {
          this.remove();
        }
        return true;
      };

      ScreenshotRectangle.prototype.setRectangle = function(rectangle, update) {
        if (update == null) {
          update = true;
        }
        ScreenshotRectangle.__super__.setRectangle.call(this, rectangle, update);
        Utils.Rectangle.updatePathRectangle(this.drawing, rectangle);
        this.updateTransform();
      };

      ScreenshotRectangle.prototype.moveTo = function(position, update) {
        ScreenshotRectangle.__super__.moveTo.call(this, position, update);
        this.updateTransform();
      };

      ScreenshotRectangle.prototype.updateTransform = function() {
        var transfrom, viewPos;
        viewPos = P.view.projectToView(this.rectangle.center);
        transfrom = 'translate(' + viewPos.x + 'px,' + viewPos.y + 'px)';
        transfrom += 'translate(-50%, -50%)';
        this.buttonJ.css({
          'position': 'absolute',
          'transform': transfrom,
          'top': 0,
          'left': 0,
          'transform-origin': '50% 50%',
          'z-index': 999
        });
      };

      ScreenshotRectangle.prototype.update = function() {};

      return ScreenshotRectangle;

    })(SelectionRectangle);
    return SelectionRectangle;
  });

}).call(this);

//# sourceMappingURL=SelectionRectangle.map
