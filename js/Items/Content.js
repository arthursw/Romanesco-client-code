// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['Items/Item'], function(Item) {
    var Content;
    Content = (function(_super) {
      __extends(Content, _super);

      Content.initializeParameters = function() {
        var parameters;
        parameters = Content.__super__.constructor.initializeParameters.call(this);
        delete parameters['Items'].align;
        parameters['Items'].duplicate = R.parameters.duplicate;
        return parameters;
      };

      Content.parameters = Content.initializeParameters();

      function Content(data, pk, date, itemListJ, sortedItems) {
        this.data = data;
        this.pk = pk;
        this.date = date;
        this.sortedItems = sortedItems;
        this.onLiClick = __bind(this.onLiClick, this);
        Content.__super__.constructor.call(this, this.data, this.pk);
        if (this.date == null) {
          this.date = Date.now();
        }
        this.rotation = this.data.rotation || 0;
        this.liJ = $("<li>");
        this.liJ.attr("data-pk", this.pk);
        this.liJ.click(this.onLiClick);
        this.liJ.mouseover((function(_this) {
          return function(event) {
            _this.highlight();
          };
        })(this));
        this.liJ.mouseout((function(_this) {
          return function(event) {
            _this.unhighlight();
          };
        })(this));
        this.liJ.rItem = this;
        itemListJ.prepend(this.liJ);
        $("#RItems .mCustomScrollbar").mCustomScrollbar("scrollTo", "bottom");
        this.updateZindex();
        return;
      }

      Content.prototype.getDuplicateData = function() {
        var data, _ref;
        data = Content.__super__.getDuplicateData.call(this);
        data.lock = (_ref = this.lock) != null ? _ref.getPk() : void 0;
        return data;
      };

      Content.prototype.onLiClick = function(event) {
        var bounds;
        if (!event.shiftKey) {
          R.tools.select.deselectAll();
          bounds = this.getBounds();
          if (!P.view.bounds.intersects(bounds)) {
            R.view.moveTo(bounds.center, 1000);
          }
        }
        this.select();
      };

      Content.prototype.rotate = function(rotation, center, update) {
        this.setRotation(this.rotation + rotation, center, update);
      };

      Content.prototype.setRotation = function(rotation, center, update) {
        var delta, deltaRotation;
        deltaRotation = rotation - this.rotation;
        this.rotation = rotation;
        this.group.rotate(deltaRotation, center);
        delta = this.rectangle.center.subtract(center);
        this.rectangle.center = center.add(delta.rotate(deltaRotation));
        if (!this.socketAction) {
          if (update) {
            this.update('rotation');
          }
          R.socket.emit("bounce", {
            itemPk: this.pk,
            "function": "setRotation",
            "arguments": [rotation, center, false]
          });
        }
      };

      Content.prototype.getData = function() {
        var data;
        data = jQuery.extend({}, Content.__super__.getData.call(this));
        data.rotation = this.rotation;
        return data;
      };

      Content.prototype.getBounds = function() {
        if (this.rotation === 0) {
          return this.rectangle;
        }
        return Utils.Rectangle.getRotatedBounds(this.rectangle, this.rotation);
      };

      Content.prototype.setZindex = function() {
        var dateLabel, zindexLabel;
        dateLabel = '' + this.date;
        dateLabel = dateLabel.substring(dateLabel.length - 7, dateLabel.length - 3);
        zindexLabel = this.constructor.label;
        if (dateLabel.length > 0) {
          zindexLabel += ' - ' + dateLabel;
        }
        this.liJ.text(zindexLabel);
      };

      Content.prototype.updateZindex = function() {
        var i, item, _i, _len, _ref;
        if (this.date == null) {
          return;
        }
        if (this.sortedItems.length === 0) {
          this.sortedItems.push(this);
          this.setZindex();
          return;
        }
        _ref = this.sortedItems;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          item = _ref[i];
          if (this.date < item.date) {
            this.insertBelow(item, i);
            return;
          }
        }
        this.insertAbove(_.last(this.sortedItems));
      };

      Content.prototype.insertAbove = function(item, index, update) {
        var nextDate, previousDate;
        if (index == null) {
          index = null;
        }
        if (update == null) {
          update = false;
        }
        this.group.insertAbove(item.group);
        if (!index) {
          Utils.Array.remove(this.sortedItems, this);
          index = this.sortedItems.indexOf(item) + 1;
        }
        this.sortedItems.splice(index, 0, this);
        this.liJ.insertBefore(item.liJ);
        if (update) {
          if (this.sortedItems[index + 1] == null) {
            this.date = Date.now();
          } else {
            previousDate = this.sortedItems[index - 1].date;
            nextDate = this.sortedItems[index + 1].date;
            this.date = (previousDate + nextDate) / 2;
          }
          this.update('z-index');
        }
        this.setZindex();
      };

      Content.prototype.insertBelow = function(item, index, update) {
        var nextDate, previousDate;
        if (index == null) {
          index = null;
        }
        if (update == null) {
          update = false;
        }
        this.group.insertBelow(item.group);
        if (!index) {
          Utils.Array.remove(this.sortedItems, this);
          index = this.sortedItems.indexOf(item);
        }
        this.sortedItems.splice(index, 0, this);
        this.liJ.insertAfter(item.liJ);
        if (update) {
          if (this.sortedItems[index - 1] == null) {
            this.date = this.sortedItems[index + 1].date - 1000;
          } else {
            previousDate = this.sortedItems[index - 1].date;
            nextDate = this.sortedItems[index + 1].date;
            this.date = (previousDate + nextDate) / 2;
          }
          this.update('z-index');
        }
        this.setZindex();
      };

      Content.prototype.setPK = function(pk) {
        var _ref;
        Content.__super__.setPK.apply(this, arguments);
        if ((_ref = this.liJ) != null) {
          _ref.attr("data-pk", this.pk);
        }
      };

      Content.prototype.select = function() {
        if (!Content.__super__.select.call(this)) {
          return false;
        }
        this.liJ.addClass('selected');
        return true;
      };

      Content.prototype.deselect = function() {
        if (!Content.__super__.deselect.call(this)) {
          return false;
        }
        this.liJ.removeClass('selected');
        return true;
      };

      Content.prototype.finish = function() {
        var bounds, lock, locks, _i, _len;
        if (!Content.__super__.finish.call(this)) {
          return false;
        }
        bounds = this.getBounds();
        if (bounds.area > R.rasterizer.maxArea()) {
          R.alertManager.alert("The item is too big", "Warning");
          this.remove();
          return false;
        }
        locks = Item.Lock.getLocksWhichIntersect(bounds);
        for (_i = 0, _len = locks.length; _i < _len; _i++) {
          lock = locks[_i];
          if (lock.rectangle.intersects(bounds)) {
            if (lock.rectangle.contains(bounds) && lock.owner === R.me) {
              lock.addItem(this);
            } else if (lock.owner !== R.me) {
              R.alertManager.alert("The item intersects with a lock", "Warning");
              this.remove();
              return false;
            }
          }
        }
        return true;
      };

      Content.prototype.remove = function() {
        var _ref;
        Content.__super__.remove.call(this);
        if (this.sortedItems != null) {
          Utils.Array.remove(this.sortedItems, this);
        }
        if ((_ref = this.liJ) != null) {
          _ref.remove();
        }
      };

      Content.prototype["delete"] = function() {
        if ((this.lock != null) && this.lock.owner !== R.me) {
          return;
        }
        Content.__super__["delete"].call(this);
      };

      Content.prototype.update = function() {};

      return Content;

    })(Item);
    Item.Content = Content;
    return Content;
  });

}).call(this);
