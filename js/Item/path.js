// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['utils', 'item', 'jquery', 'paper'], function(utils) {
    var Checkpoint, DynamicBrush, EllipseShape, GeometricLines, GridPath, Meander, Medusa, PaintBrush, PaintGun, PrecisePath, RPath, RShape, RectangleShape, ShapePath, SpeedPath, SpiralShape, StarShape, StripeAnimation, ThicknessPath, g;
    g = utils.g();
    RPath = (function(_super) {
      __extends(RPath, _super);

      RPath.rname = 'Pen';

      RPath.rdescription = "The classic and basic pen tool";

      RPath.cursorPosition = {
        x: 24,
        y: 0
      };

      RPath.cursorDefault = "crosshair";

      RPath.constructor.secureDistance = 2;

      RPath.initializeParameters = function() {
        var parameters;
        return parameters = {
          'Items': {
            align: g.parameters.align,
            distribute: g.parameters.distribute,
            duplicate: g.parameters.duplicate,
            "delete": g.parameters["delete"],
            editTool: {
              type: 'button',
              label: 'Edit tool',
              "default": (function(_this) {
                return function() {
                  return g.showEditor(_this);
                };
              })(this)
            }
          },
          'Style': {
            strokeWidth: $.extend(true, {}, g.parameters.strokeWidth),
            strokeColor: $.extend(true, {}, g.parameters.strokeColor),
            fillColor: $.extend(true, {}, g.parameters.fillColor)
          },
          'Shadow': {
            folderIsClosedByDefault: true,
            shadowOffsetX: {
              type: 'slider',
              label: 'Shadow offset x',
              min: -25,
              max: 25,
              "default": 0
            },
            shadowOffsetY: {
              type: 'slider',
              label: 'Shadow offset y',
              min: -25,
              max: 25,
              "default": 0
            },
            shadowBlur: {
              type: 'slider',
              label: 'Shadow blur',
              min: 0,
              max: 50,
              "default": 0
            },
            shadowColor: {
              type: 'color',
              label: 'Shadow color',
              "default": '#000',
              defaultCheck: false
            }
          }
        };
      };

      RPath.parameters = RPath.initializeParameters();

      RPath.create = function(duplicateData) {
        var copy;
        if (duplicateData == null) {
          duplicateData = this.getDuplicateData();
        }
        copy = new this(duplicateData.date, duplicateData.data, null, duplicateData.points);
        copy.draw();
        if (!this.socketAction) {
          copy.save(false);
          g.chatSocket.emit("bounce", {
            itemClass: this.name,
            "function": "create",
            "arguments": [duplicateData]
          });
        }
        return copy;
      };

      function RPath(date, data, pk, points, lock) {
        this.date = date != null ? date : null;
        this.data = data != null ? data : null;
        this.pk = pk != null ? pk : null;
        if (points == null) {
          points = null;
        }
        this.lock = lock != null ? lock : null;
        this.update = __bind(this.update, this);
        this.saveCallback = __bind(this.saveCallback, this);
        if (!this.lock) {
          RPath.__super__.constructor.call(this, this.data, this.pk, this.date, g.pathList, g.sortedPaths);
        } else {
          RPath.__super__.constructor.call(this, this.data, this.pk, this.date, this.lock.itemListsJ.find('.rPath-list'), this.lock.sortedPaths);
        }
        this.selectionHighlight = null;
        if (points != null) {
          this.loadPath(points);
        }
        return;
      }

      RPath.prototype.getDuplicateData = function() {
        return {
          data: this.getData(),
          points: this.pathOnPlanet(),
          date: this.date
        };
      };

      RPath.prototype.getDrawingBounds = function() {
        if (!this.canvasRaster && (this.drawing != null) && this.drawing.strokeBounds.area > 0) {
          if (this.raster != null) {
            return this.raster.bounds;
          }
          return this.drawing.strokeBounds;
        }
        return this.getBounds().expand(this.data.strokeWidth);
      };

      RPath.prototype.endSetRectangle = function() {
        RPath.__super__.endSetRectangle.call(this);
        this.draw();
        this.rasterize();
      };

      RPath.prototype.setRectangle = function(event, update) {
        RPath.__super__.setRectangle.call(this, event, update);
        this.draw(update);
      };

      RPath.prototype.projectToRaster = function(point) {
        return point.subtract(this.canvasRaster.bounds.topLeft);
      };

      RPath.prototype.prepareHitTest = function(fullySelected, strokeWidth) {
        var _ref;
        RPath.__super__.prepareHitTest.call(this);
        this.stateBeforeHitTest = {};
        this.stateBeforeHitTest.groupWasVisible = this.group.visible;
        this.stateBeforeHitTest.controlPathWasVisible = this.controlPath.visible;
        this.stateBeforeHitTest.controlPathWasSelected = this.controlPath.selected;
        this.stateBeforeHitTest.controlPathWasFullySelected = this.controlPath.fullySelected;
        this.stateBeforeHitTest.controlPathStrokeWidth = this.controlPath.strokeWidth;
        this.group.visible = true;
        this.controlPath.visible = true;
        this.controlPath.selected = true;
        if (strokeWidth) {
          this.controlPath.strokeWidth = strokeWidth;
        }
        if (fullySelected) {
          this.controlPath.fullySelected = true;
        }
        if ((_ref = this.speedGroup) != null) {
          _ref.selected = true;
        }
      };

      RPath.prototype.finishHitTest = function(fullySelected) {
        var _ref;
        if (fullySelected == null) {
          fullySelected = true;
        }
        RPath.__super__.finishHitTest.call(this, fullySelected);
        this.group.visible = this.stateBeforeHitTest.groupWasVisible;
        this.controlPath.visible = this.stateBeforeHitTest.controlPathWasVisible;
        this.controlPath.strokeWidth = this.stateBeforeHitTest.controlPathStrokeWidth;
        this.controlPath.fullySelected = this.stateBeforeHitTest.controlPathWasFullySelected;
        if (!this.controlPath.fullySelected) {
          this.controlPath.selected = this.stateBeforeHitTest.controlPathWasSelected;
        }
        this.stateBeforeHitTest = null;
        if ((_ref = this.speedGroup) != null) {
          _ref.selected = false;
        }
      };

      RPath.prototype.select = function() {
        if (!RPath.__super__.select.call(this) || (this.controlPath == null)) {
          return false;
        }
        return true;
      };

      RPath.prototype.deselect = function() {
        if (!RPath.__super__.deselect.call(this)) {
          return false;
        }
        return true;
      };

      RPath.prototype.beginAction = function(command) {
        RPath.__super__.beginAction.call(this, command);
      };

      RPath.prototype.endAction = function() {
        RPath.__super__.endAction.call(this);
      };

      RPath.prototype.updateSelect = function(event) {
        RPath.__super__.updateSelect.call(this, event);
      };

      RPath.prototype.doubleClick = function(event) {};

      RPath.prototype.loadPath = function(points) {};

      RPath.prototype.setParameter = function(controller, value, updateGUI, update) {
        RPath.__super__.setParameter.call(this, controller, value, updateGUI, update);
        if (this.previousBoundingBox == null) {
          this.previousBoundingBox = this.getDrawingBounds();
        }
        this.draw();
      };

      RPath.prototype.applyStylesToPath = function(path) {
        path.strokeColor = this.data.strokeColor;
        path.strokeWidth = this.data.strokeWidth;
        path.fillColor = this.data.fillColor;
        if (this.data.shadowOffsetY != null) {
          path.shadowOffset = new Point(this.data.shadowOffsetX, this.data.shadowOffsetY);
        }
        if (this.data.shadowBlur != null) {
          path.shadowBlur = this.data.shadowBlur;
        }
        if (this.data.shadowColor != null) {
          path.shadowColor = this.data.shadowColor;
        }
      };

      RPath.prototype.addPath = function(path, applyStyles) {
        if (applyStyles == null) {
          applyStyles = true;
        }
        if (path == null) {
          path = new Path();
        }
        path.controller = this;
        if (applyStyles) {
          this.applyStylesToPath(path);
        }
        this.drawing.addChild(path);
        return path;
      };

      RPath.prototype.addControlPath = function(controlPath) {
        this.controlPath = controlPath;
        if (this.lock) {
          this.lock.group.addChild(this.group);
        }
        if (this.controlPath == null) {
          this.controlPath = new Path();
        }
        this.group.addChild(this.controlPath);
        this.controlPath.name = "controlPath";
        this.controlPath.controller = this;
        this.controlPath.strokeWidth = 10;
        this.controlPath.strokeColor = g.selectionBlue;
        this.controlPath.strokeColor.alpha = 0.25;
        this.controlPath.strokeCap = 'round';
        this.controlPath.visible = false;
      };

      RPath.prototype.initializeDrawing = function(createCanvas) {
        var bounds, canvas, position, _ref, _ref1, _ref2;
        if (createCanvas == null) {
          createCanvas = false;
        }
        if ((_ref = this.raster) != null) {
          _ref.remove();
        }
        this.raster = null;
        this.controlPath.strokeWidth = 10;
        if ((_ref1 = this.drawing) != null) {
          _ref1.remove();
        }
        this.drawing = new Group();
        this.drawing.name = "drawing";
        this.drawing.strokeColor = this.data.strokeColor;
        this.drawing.strokeWidth = this.data.strokeWidth;
        this.drawing.fillColor = this.data.fillColor;
        this.drawing.insertBelow(this.controlPath);
        this.drawing.controlPath = this.controlPath;
        this.drawing.controller = this;
        this.group.addChild(this.drawing);
        if (createCanvas) {
          canvas = document.createElement("canvas");
          if (this.rectangle.area < 2) {
            canvas.width = view.size.width;
            canvas.height = view.size.height;
            position = view.center;
          } else {
            bounds = this.getDrawingBounds();
            canvas.width = bounds.width;
            canvas.height = bounds.height;
            position = bounds.center;
          }
          if ((_ref2 = this.canvasRaster) != null) {
            _ref2.remove();
          }
          this.canvasRaster = new Raster(canvas, position);
          this.drawing.addChild(this.canvasRaster);
          this.context = this.canvasRaster.canvas.getContext("2d");
          this.context.strokeStyle = this.data.strokeColor;
          this.context.fillStyle = this.data.fillColor;
          this.context.lineWidth = this.data.strokeWidth;
        }
      };

      RPath.prototype.setAnimated = function(animated) {
        if (animated) {
          g.registerAnimation(this);
        } else {
          g.deregisterAnimation(this);
        }
      };

      RPath.prototype.draw = function(simplified) {
        if (simplified == null) {
          simplified = false;
        }
      };

      RPath.prototype.initialize = function() {};

      RPath.prototype.beginCreate = function(point, event) {};

      RPath.prototype.updateCreate = function(point, event) {};

      RPath.prototype.endCreate = function(point, event) {};

      RPath.prototype.insertAbove = function(path, index, update) {
        if (index == null) {
          index = null;
        }
        if (update == null) {
          update = false;
        }
        this.zindex = this.group.index;
        RPath.__super__.insertAbove.call(this, path, index, update);
      };

      RPath.prototype.insertBelow = function(path, index, update) {
        if (index == null) {
          index = null;
        }
        if (update == null) {
          update = false;
        }
        this.zindex = this.group.index;
        RPath.__super__.insertBelow.call(this, path, index, update);
      };

      RPath.prototype.getData = function() {
        return this.data;
      };

      RPath.prototype.getStringifiedData = function() {
        return JSON.stringify(this.getData());
      };

      RPath.prototype.getPlanet = function() {
        return g.projectToPlanet(this.controlPath.segments[0].point);
      };

      RPath.prototype.save = function(addCreateCommand) {
        var args;
        if (addCreateCommand == null) {
          addCreateCommand = true;
        }
        if (this.controlPath == null) {
          return;
        }
        g.paths[this.pk != null ? this.pk : this.id] = this;
        args = {
          city: g.city,
          box: g.boxFromRectangle(this.getDrawingBounds()),
          points: this.pathOnPlanet(),
          data: this.getStringifiedData(),
          date: this.date,
          object_type: this.constructor.rname
        };
        Dajaxice.draw.savePath(this.saveCallback, args);
        RPath.__super__.save.apply(this, arguments);
      };

      RPath.prototype.saveCallback = function(result) {
        g.checkError(result);
        if (result.pk == null) {
          return;
        }
        this.setPK(result.pk);
        if (this.updateAfterSave != null) {
          this.update(this.updateAfterSave);
        }
        RPath.__super__.saveCallback.apply(this, arguments);
      };

      RPath.prototype.getUpdateFunction = function() {
        return 'updatePath';
      };

      RPath.prototype.getUpdateArguments = function(type) {
        var args;
        switch (type) {
          case 'z-index':
            args = {
              pk: this.pk,
              date: this.date
            };
            break;
          default:
            args = {
              pk: this.pk,
              points: this.pathOnPlanet(),
              data: this.getStringifiedData(),
              box: g.boxFromRectangle(this.getDrawingBounds())
            };
        }
        return args;
      };

      RPath.prototype.update = function(type) {
        if (this.pk == null) {
          this.updateAfterSave = type;
          return;
        }
        delete this.updateAfterSave;
        Dajaxice.draw.updatePath(this.updatePathCallback, this.getUpdateArguments(type));
      };

      RPath.prototype.updatePathCallback = function(result) {
        g.checkError(result);
      };

      RPath.prototype.setPK = function(pk) {
        RPath.__super__.setPK.apply(this, arguments);
        g.paths[pk] = this;
        delete g.paths[this.id];
      };

      RPath.prototype.remove = function() {
        if (!this.group) {
          return;
        }
        g.deregisterAnimation();
        this.controlPath = null;
        this.drawing = null;
        if (this.raster == null) {
          this.raster = null;
        }
        if (this.canvasRaster == null) {
          this.canvasRaster = null;
        }
        if (this.pk != null) {
          delete g.paths[this.pk];
        } else {
          delete g.paths[this.id];
        }
        RPath.__super__.remove.call(this);
      };

      RPath.prototype["delete"] = function() {
        if ((this.lock != null) && this.lock.owner !== g.me) {
          return;
        }
        this.group.visible = false;
        this.remove();
        if (this.pk == null) {
          return;
        }
        console.log(this.pk);
        if (!this.socketAction) {
          Dajaxice.draw.deletePath(g.checkError, {
            pk: this.pk
          });
        }
        RPath.__super__["delete"].apply(this, arguments);
      };

      RPath.prototype.pathOnPlanet = function(controlSegments) {
        var p, planet, points, segment, _i, _len;
        if (controlSegments == null) {
          controlSegments = this.controlPath.segments;
        }
        points = [];
        planet = this.getPlanet();
        for (_i = 0, _len = controlSegments.length; _i < _len; _i++) {
          segment = controlSegments[_i];
          p = g.projectToPosOnPlanet(segment.point, planet);
          points.push(g.pointToArray(p));
        }
        return points;
      };

      return RPath;

    })(g.RContent);
    g.RPath = RPath;
    PrecisePath = (function(_super) {
      __extends(PrecisePath, _super);

      PrecisePath.rname = 'Precise path';

      PrecisePath.rdescription = "This path offers precise controls, one can modify points along with their handles and their type.";

      PrecisePath.iconURL = 'static/images/icons/inverted/editCurve.png';

      PrecisePath.iconAlt = 'edit curve';

      PrecisePath.hitOptions = {
        segments: true,
        stroke: true,
        fill: true,
        selected: true,
        curves: true,
        handles: true,
        tolerance: 5
      };

      PrecisePath.secureStep = 25;

      PrecisePath.polygonMode = true;

      PrecisePath.renderType = 'simple';

      PrecisePath.initializeParameters = function() {
        var parameters;
        parameters = PrecisePath.__super__.constructor.initializeParameters.call(this);
        if (this.polygonMode) {
          parameters['Items'].polygonMode = {
            type: 'checkbox',
            label: 'Polygon mode',
            "default": g.polygonMode,
            onChange: function(value) {
              return g.polygonMode = value;
            }
          };
        }
        parameters['Edit curve'] = {
          smooth: {
            type: 'checkbox',
            label: 'Smooth',
            "default": false,
            onChange: function(value) {
              var item, _i, _len, _ref;
              _ref = g.selectedItems;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                if (typeof item.setSmooth === "function") {
                  item.setSmooth(value);
                }
              }
            }
          },
          pointType: {
            type: 'dropdown',
            label: 'Point type',
            values: ['smooth', 'corner', 'point'],
            "default": 'smooth',
            addController: true,
            onChange: function(value) {
              var item, _i, _len, _ref;
              _ref = g.selectedItems;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                if (typeof item.modifyPointTypeCommand === "function") {
                  item.modifyPointTypeCommand(value);
                }
              }
            }
          },
          deletePoint: {
            type: 'button',
            label: 'Delete point',
            "default": function() {
              var item, _i, _len, _ref;
              _ref = g.selectedItems;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                if (typeof item.deletePointCommand === "function") {
                  item.deletePointCommand();
                }
              }
            }
          },
          simplify: {
            type: 'button',
            label: 'Simplify',
            "default": function(value) {
              var item, _i, _len, _ref;
              _ref = g.selectedItems;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                item = _ref[_i];
                if (typeof item.simplifyControlPath === "function") {
                  item.simplifyControlPath(value);
                }
              }
            },
            onChange: function(value) {}
          },
          showSelectionRectangle: {
            type: 'checkbox',
            label: 'Selection box',
            "default": true
          }
        };
        return parameters;
      };

      PrecisePath.parameters = PrecisePath.initializeParameters();

      function PrecisePath(date, data, pk, points, lock) {
        this.date = date != null ? date : null;
        this.data = data != null ? data : null;
        this.pk = pk != null ? pk : null;
        if (points == null) {
          points = null;
        }
        this.lock = lock;
        PrecisePath.__super__.constructor.call(this, this.date, this.data, this.pk, points, this.lock);
        if (this.constructor.polygonMode) {
          this.data.polygonMode = g.polygonMode;
        }
        this.rotation = this.data.rotation = 0;
        return;
      }

      PrecisePath.prototype.setControlPath = function(points, planet) {
        var i, point, _i, _len;
        for (i = _i = 0, _len = points.length; _i < _len; i = _i += 4) {
          point = points[i];
          this.controlPath.add(g.posOnPlanetToProject(point, planet));
          this.controlPath.lastSegment.handleIn = new Point(points[i + 1]);
          this.controlPath.lastSegment.handleOut = new Point(points[i + 2]);
          this.controlPath.lastSegment.rtype = points[i + 3];
        }
      };

      PrecisePath.prototype.loadPath = function(points) {
        var distanceMax, flattenedPath, i, index, recordedPoint, resultingPoint, time, _i;
        this.addControlPath();
        this.setControlPath(this.data.points, this.data.planet);
        this.rectangle = this.controlPath.bounds;
        if (this.data.smooth) {
          this.controlPath.smooth();
        }
        g.rasterizer.loadItem(this);
        time = Date.now();
        flattenedPath = this.controlPath.copyTo(project);
        flattenedPath.flatten(this.constructor.secureStep);
        distanceMax = this.constructor.secureDistance * this.constructor.secureDistance;
        for (i = _i = 1; _i <= 10; i = ++_i) {
          index = Math.floor(Math.random() * points.length);
          recordedPoint = new Point(points[index]);
          resultingPoint = flattenedPath.segments[index].point;
          if (recordedPoint.getDistance(resultingPoint, true) > distanceMax) {
            flattenedPath.strokeColor = 'red';
            view.center = flattenedPath.bounds.center;
            console.log("Error: invalid path");
            return;
          }
        }
        flattenedPath.remove();
        console.log("Time to secure the path: " + ((Date.now() - time) / 1000) + " sec.");
      };

      PrecisePath.prototype.hitTest = function(point, hitOptions) {
        var hitResult, _ref, _ref1;
        if ((_ref = this.speedGroup) != null ? _ref.visible : void 0) {
          hitResult = (_ref1 = this.handleGroup) != null ? _ref1.hitTest(point) : void 0;
        }
        if (hitResult == null) {
          hitResult = PrecisePath.__super__.hitTest.call(this, point, hitOptions);
        }
        if (hitResult == null) {
          hitResult = this.controlPath.hitTest(point, hitOptions);
        }
        return hitResult;
      };

      PrecisePath.prototype.initializeDrawing = function(createCanvas) {
        var _base;
        if (createCanvas == null) {
          createCanvas = false;
        }
        if ((_base = this.data).step == null) {
          _base.step = 20;
        }
        this.drawingOffset = 0;
        PrecisePath.__super__.initializeDrawing.call(this, createCanvas);
      };

      PrecisePath.prototype.beginDraw = function(redrawing) {
        if (redrawing == null) {
          redrawing = false;
        }
        this.initializeDrawing(false);
        this.path = this.addPath();
        this.path.segments = this.controlPath.segments;
        this.path.selected = false;
        this.path.strokeCap = 'round';
      };

      PrecisePath.prototype.updateDraw = function(offset, step, redrawing) {
        this.path.segments = this.controlPath.segments;
        this.path.selected = false;
        this.applyStylesToPath(this.path);
      };

      PrecisePath.prototype.endDraw = function(redrawing) {
        if (redrawing == null) {
          redrawing = false;
        }
        this.path.segments = this.controlPath.segments;
        this.path.selected = false;
      };

      PrecisePath.prototype.checkUpdateDrawing = function(segment, redrawing) {
        var controlPathOffset, step;
        if (redrawing == null) {
          redrawing = true;
        }
        step = this.data.step;
        controlPathOffset = segment.location.offset;
        while (this.drawingOffset + step < controlPathOffset) {
          this.drawingOffset += step;
          this.updateDraw(this.drawingOffset, true, redrawing);
        }
        if (this.drawingOffset + step > controlPathOffset) {
          this.updateDraw(controlPathOffset, false, redrawing);
        }
      };

      PrecisePath.prototype.beginCreate = function(point, event) {
        PrecisePath.__super__.beginCreate.call(this);
        if (!this.data.polygonMode) {
          this.addControlPath();
          this.controlPath.add(point);
          this.rectangle = this.controlPath.bounds;
          this.beginDraw(false);
        } else {
          if (this.controlPath == null) {
            this.addControlPath();
            this.controlPath.add(point);
            this.rectangle = this.controlPath.bounds;
            this.controlPath.add(point);
            this.beginDraw(false);
          } else {
            this.controlPath.add(point);
          }
          this.controlPath.lastSegment.rtype = 'point';
        }
      };

      PrecisePath.prototype.updateCreate = function(point, event) {
        var lastSegment, previousSegment;
        if (!this.data.polygonMode) {
          this.controlPath.add(point);
          this.checkUpdateDrawing(this.controlPath.lastSegment, false);
        } else {
          lastSegment = this.controlPath.lastSegment;
          previousSegment = lastSegment.previous;
          previousSegment.rtype = 'smooth';
          previousSegment.handleOut = point.subtract(previousSegment.point);
          if (lastSegment !== this.controlPath.firstSegment) {
            previousSegment.handleIn = previousSegment.handleOut.multiply(-1);
          }
          lastSegment.handleIn = lastSegment.handleOut = null;
          lastSegment.point = point;
          console.log('update create');
          this.draw(true, false);
        }
      };

      PrecisePath.prototype.createMove = function(event) {
        this.controlPath.lastSegment.point = event.point;
        console.log('create move');
        this.draw(true, false);
      };

      PrecisePath.prototype.endCreate = function(point, event) {
        var segment, _i, _len, _ref;
        if (this.data.polygonMode) {
          return;
        }
        if (this.controlPath.segments.length >= 2) {
          this.controlPath.simplify();
          _ref = this.controlPath.segments;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            segment = _ref[_i];
            if (segment.handleIn.length > 200) {
              segment.handleIn = segment.handleIn.normalize().multiply(100);
              console.log('ADJUSTING HANDLE LENGTH');
            }
            if (segment.handleOut.length > 200) {
              segment.handleOut = segment.handleOut.normalize().multiply(100);
              console.log('ADJUSTING HANDLE LENGTH');
            }
          }
        }
        this.finish();
        PrecisePath.__super__.endCreate.call(this);
      };

      PrecisePath.prototype.finish = function() {
        if (this.data.polygonMode) {
          this.controlPath.lastSegment.remove();
          this.controlPath.lastSegment.handleOut = null;
        }
        if (this.controlPath.segments.length < 2) {
          this.remove();
          return false;
        }
        if (this.data.smooth) {
          this.controlPath.smooth();
        }
        this.endDraw();
        this.drawingOffset = 0;
        this.rectangle = this.controlPath.bounds;
        if (!PrecisePath.__super__.finish.call(this)) {
          return false;
        }
        this.initialize();
        return true;
      };

      PrecisePath.prototype.simplifiedModeOn = function() {
        var folder, folderName, name, parameter, _ref;
        this.previousData = {};
        _ref = this.constructor.parameters;
        for (folderName in _ref) {
          folder = _ref[folderName];
          for (name in folder) {
            parameter = folder[name];
            if ((parameter.simplified != null) && (this.data[name] != null)) {
              this.previousData[name] = this.data[name];
              this.data[name] = parameter.simplified;
            }
          }
        }
      };

      PrecisePath.prototype.simplifiedModeOff = function() {
        var folder, folderName, name, parameter, _ref;
        _ref = this.constructor.parameters;
        for (folderName in _ref) {
          folder = _ref[folderName];
          for (name in folder) {
            parameter = folder[name];
            if ((parameter.simplified != null) && (this.data[name] != null) && (this.previousData[name] != null)) {
              this.data[name] = this.previousData[name];
              delete this.previousData[name];
            }
          }
        }
      };

      PrecisePath.prototype.draw = function(simplified, redrawing) {
        var controlPathLength, error, nIteration, nf, offset, process, reminder, step;
        if (simplified == null) {
          simplified = false;
        }
        if (redrawing == null) {
          redrawing = true;
        }
        this.drawn = false;
        if (!g.rasterizer.requestDraw(this, simplified, redrawing)) {
          return;
        }
        if (this.controlPath.segments.length < 2) {
          return;
        }
        if (simplified) {
          this.simplifiedModeOn();
        }
        step = this.data.step;
        controlPathLength = this.controlPath.length;
        nf = controlPathLength / step;
        nIteration = Math.floor(nf);
        reminder = nf - nIteration;
        offset = reminder * step / 2;
        this.drawingOffset = 0;
        if (this.constructor.renderType === 'simple') {
          process = (function(_this) {
            return function() {
              _this.beginDraw();
              _this.updateDraw();
              return _this.endDraw();
            };
          })(this);
        } else {
          process = (function(_this) {
            return function() {
              var i, segment, _i, _len, _ref;
              _this.beginDraw(redrawing);
              _ref = _this.controlPath.segments;
              for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                segment = _ref[i];
                if (i === 0) {
                  continue;
                }
                _this.checkUpdateDrawing(segment, redrawing);
              }
              _this.endDraw(redrawing);
            };
          })(this);
        }
        if (!g.catchErrors) {
          process();
        } else {
          try {
            process();
          } catch (_error) {
            error = _error;
            console.error(error.stack);
            console.error(error);
            throw error;
          }
        }
        if (simplified) {
          this.simplifiedModeOff();
        }
        this.drawn = true;
      };

      PrecisePath.prototype.pathOnPlanet = function() {
        var flatennedPath;
        flatennedPath = this.controlPath.copyTo(project);
        flatennedPath.flatten(this.constructor.secureStep);
        flatennedPath.remove();
        return PrecisePath.__super__.pathOnPlanet.call(this, flatennedPath.segments);
      };

      PrecisePath.prototype.getPoints = function() {
        var points, segment, _i, _len, _ref;
        points = [];
        _ref = this.controlPath.segments;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          segment = _ref[_i];
          points.push(g.projectToPosOnPlanet(segment.point));
          points.push(g.pointToObj(segment.handleIn));
          points.push(g.pointToObj(segment.handleOut));
          points.push(segment.rtype);
        }
        return points;
      };

      PrecisePath.prototype.getPointsAndPlanet = function() {
        return {
          planet: this.getPlanet(),
          points: this.getPoints()
        };
      };

      PrecisePath.prototype.getData = function() {
        this.data.planet = this.getPlanet();
        this.data.points = this.getPoints();
        return this.data;
      };

      PrecisePath.prototype.select = function() {
        if (!PrecisePath.__super__.select.call(this)) {
          return;
        }
        this.controlPath.selected = true;
        if (!this.data.smooth) {
          this.controlPath.fullySelected = true;
        }
        return true;
      };

      PrecisePath.prototype.deselect = function() {
        var _ref, _ref1;
        if (!PrecisePath.__super__.deselect.call(this)) {
          return false;
        }
        if ((_ref = this.controlPath) != null) {
          _ref.selected = false;
        }
        if ((_ref1 = this.selectionHighlight) != null) {
          _ref1.remove();
        }
        this.selectionHighlight = null;
        return true;
      };

      PrecisePath.prototype.highlightSelectedPoint = function() {
        var offset, point, _base, _ref;
        if (!this.controlPath.selected) {
          return;
        }
        if ((_ref = this.selectionHighlight) != null) {
          _ref.remove();
        }
        this.selectionHighlight = null;
        if (this.selectionState.segment == null) {
          return;
        }
        point = this.selectionState.segment.point;
        if ((_base = this.selectionState.segment).rtype == null) {
          _base.rtype = 'smooth';
        }
        switch (this.selectionState.segment.rtype) {
          case 'smooth':
            this.selectionHighlight = new Path.Circle(point, 5);
            break;
          case 'corner':
            offset = new Point(5, 5);
            this.selectionHighlight = new Path.Rectangle(point.subtract(offset), point.add(offset));
            break;
          case 'point':
            this.selectionHighlight = new Path.RegularPolygon(point, 3, 5);
        }
        this.selectionHighlight.name = 'selection highlight';
        this.selectionHighlight.controller = this;
        this.selectionHighlight.strokeColor = g.selectionBlue;
        this.selectionHighlight.strokeWidth = 1;
        g.selectionLayer.addChild(this.selectionHighlight);
        this.constructor.parameters['Edit curve'].pointType.controller.setValue(this.selectionState.segment.rtype);
      };

      PrecisePath.prototype.initializeSelection = function(event, hitResult) {
        var specialKey;
        PrecisePath.__super__.initializeSelection.call(this, event, hitResult);
        specialKey = g.specialKey(event);
        if (hitResult.type === 'segment') {
          if (specialKey && hitResult.item === this.controlPath) {
            this.selectionState = {
              segment: hitResult.segment
            };
            this.deletePointCommand();
          } else {
            if (hitResult.item === this.controlPath) {
              this.selectionState = {
                segment: hitResult.segment
              };
            }
          }
        }
        if (!this.data.smooth) {
          if (hitResult.type === "handle-in") {
            this.selectionState = {
              segment: hitResult.segment,
              handle: hitResult.segment.handleIn
            };
          } else if (hitResult.type === "handle-out") {
            this.selectionState = {
              segment: hitResult.segment,
              handle: hitResult.segment.handleOut
            };
          }
        }
        this.highlightSelectedPoint();
      };

      PrecisePath.prototype.beginSelect = function(event) {
        var _ref;
        if ((_ref = this.selectionHighlight) != null) {
          _ref.remove();
        }
        this.selectionHighlight = null;
        PrecisePath.__super__.beginSelect.call(this, event);
        if (this.selectionState.segment != null) {
          this.beginAction(new g.ModifyPointCommand(this));
        } else if (this.selectionState.speedHandle != null) {
          this.beginAction(new g.ModifySpeedCommand(this));
        }
      };

      PrecisePath.prototype.updateSelect = function(event) {
        PrecisePath.__super__.updateSelect.call(this, event);
      };

      PrecisePath.prototype.updateSelectionRectangle = function(reset) {
        if (reset == null) {
          reset = false;
        }
        if (reset) {
          this.controlPath.firstSegment.point = this.controlPath.firstSegment.point;
          this.rectangle = this.controlPath.bounds.clone();
          this.rotation = 0;
        }
        PrecisePath.__super__.updateSelectionRectangle.call(this);
        this.controlPath.pivot = this.selectionRectangle.pivot;
        this.selectionRectangle.selected = this.data.showSelectionRectangle;
        this.selectionRectangle.visible = this.data.showSelectionRectangle;
      };

      PrecisePath.prototype.setRectangle = function(rectangle, update) {
        var previousRectangle;
        previousRectangle = this.rectangle.clone();
        PrecisePath.__super__.setRectangle.call(this, rectangle, update);
        this.controlPath.pivot = previousRectangle.center;
        this.controlPath.rotate(-this.rotation);
        this.controlPath.scale(this.rectangle.width / previousRectangle.width, this.rectangle.height / previousRectangle.height);
        this.controlPath.position = this.rectangle.center;
        this.controlPath.pivot = this.rectangle.center;
        this.controlPath.rotate(this.rotation);
      };

      PrecisePath.prototype.smoothPoint = function(segment, offset) {
        var tangent;
        segment.rtype = 'smooth';
        segment.linear = false;
        if (offset == null) {
          offset = segment.location.offset;
        }
        tangent = segment.path.getTangentAt(offset);
        if (segment.previous != null) {
          segment.handleIn = tangent.multiply(-0.25);
        }
        if (segment.next != null) {
          segment.handleOut = tangent.multiply(+0.25);
        }
      };

      PrecisePath.prototype.doubleClick = function(event) {
        var hitResult, point, segment;
        point = view.viewToProject(new Point(event.pageX, event.pageY));
        hitResult = this.performHitTest(point, this.constructor.hitOptions);
        if (hitResult == null) {
          return;
        }
        switch (hitResult.type) {
          case 'segment':
            segment = hitResult.segment;
            this.selectionState.segment = segment;
            switch (segment.rtype) {
              case 'smooth':
              case null:
              case void 0:
                this.modifySelectedPointType('corner');
                break;
              case 'corner':
                this.modifySelectedPointType('point');
                break;
              case 'point':
                this.deletePointCommand();
                break;
              default:
                console.log("segment.rtype not known.");
            }
            break;
          case 'stroke':
          case 'curve':
            this.addPointCommand(hitResult.location);
        }
      };

      PrecisePath.prototype.addPointCommand = function(location) {
        g.commandManager.add(new g.AddPointCommand(this, location), true);
      };

      PrecisePath.prototype.addPointAt = function(location, update) {
        if (update == null) {
          update = true;
        }
        if (!CurveLocation.prototype.isPrototypeOf(location)) {
          location = this.controlPath.getLocationAt(location);
        }
        return this.addPoint(location.index, location.point, location.offset, update);
      };

      PrecisePath.prototype.addPoint = function(index, point, offset, update) {
        var segment;
        if (update == null) {
          update = true;
        }
        segment = this.controlPath.insert(index + 1, new Point(point));
        if (this.data.smooth) {
          this.controlPath.smooth();
        } else {
          this.smoothPoint(segment, offset);
        }
        this.draw();
        if (!this.socketAction) {
          segment.selected = true;
          this.selectionState.segment = segment;
          this.highlightSelectedPoint();
          if (update) {
            this.update('point');
          }
          g.chatSocket.emit("bounce", {
            itemPk: this.pk,
            "function": "addPoint",
            "arguments": [index, point, offset, false]
          });
        }
        return segment;
      };

      PrecisePath.prototype.deletePointCommand = function() {
        if (this.selectionState.segment == null) {
          return;
        }
        g.commandManager.add(new g.DeletePointCommand(this, this.selectionState.segment), true);
      };

      PrecisePath.prototype.deletePoint = function(segment, update) {
        var location;
        if (update == null) {
          update = true;
        }
        if (!segment) {
          return;
        }
        if (!Segment.prototype.isPrototypeOf(segment)) {
          segment = this.controlPath.segments[segment];
        }
        this.selectionState.segment = segment.next != null ? segment.next : segment.previous;
        if (this.selectionState.segment) {
          this.selectionHighlight.position = this.selectionState.segment.point;
        }
        location = {
          index: segment.location.index - 1,
          point: segment.location.point 
        };
        segment.remove();
        if (this.controlPath.segments.length <= 1) {
          this.deleteCommand();
          return;
        }
        if (this.data.smooth) {
          this.controlPath.smooth();
        }
        this.draw();
        if (!this.socketAction) {
          this.updateSelectionRectangle(true);
          if (update) {
            this.update('point');
          }
          g.chatSocket.emit("bounce", {
            itemPk: this.pk,
            "function": "deletePoint",
            "arguments": [segment.index, false]
          });
        }
        return location;
      };

      PrecisePath.prototype.deleteSelectedPoint = function() {
        this.deletePoint(this.selectionState.segment);
      };

      PrecisePath.prototype.modifySelectedPoint = function(position, handleIn, handleOut, fastDraw, update) {
        if (fastDraw == null) {
          fastDraw = true;
        }
        if (update == null) {
          update = true;
        }
        this.modifyPoint(this.selectionState.segment, position, handleIn, handleOut, fastDraw, update);
      };

      PrecisePath.prototype.modifyPoint = function(segment, position, handleIn, handleOut, fastDraw, update) {
        if (fastDraw == null) {
          fastDraw = true;
        }
        if (update == null) {
          update = true;
        }
        if (!Segment.prototype.isPrototypeOf(segment)) {
          segment = this.controlPath.segments[segment];
        }
        segment.point = new Point(position);
        segment.handleIn = new Point(handleIn);
        segment.handleOut = new Point(handleOut);
        this.draw(fastDraw);
        if (fastDraw && (this.selectionHighlight != null)) {
          this.selectionHighlight.position = segment.point;
          this.selectionHighlight.bringToFront();
        } else {
          this.highlightSelectedPoint();
        }
        if (this.selectionRectangle != null) {
          this.updateSelectionRectangle(true);
        }
        if (!this.socketAction) {
          if (update) {
            this.update('segment');
          }
          g.chatSocket.emit("bounce", {
            itemPk: this.pk,
            "function": "modifyPoint",
            "arguments": [segment.index, position, handleIn, handleOut, fastDraw, false]
          });
        }
      };

      PrecisePath.prototype.updateModifyPoint = function(event) {
        var point, segment;
        segment = this.selectionState.segment;
        if (this.selectionState.handle != null) {
          if (g.getSnap() >= 1) {
            point = g.snap2D(event.point);
            this.selectionState.handle.x = point.x - segment.point.x;
            this.selectionState.handle.y = point.y - segment.point.y;
          } else {
            this.selectionState.handle.x += event.delta.x;
            this.selectionState.handle.y += event.delta.y;
          }
          if (segment.rtype === 'smooth' || (segment.rtype == null)) {
            if (this.selectionState.handle === segment.handleOut && !segment.handleIn.isZero()) {
              if (!event.modifiers.shift) {
                segment.handleIn = segment.handleOut.normalize().multiply(-segment.handleIn.length);
              } else {
                segment.handleIn = segment.handleOut.multiply(-1);
              }
            }
            if (this.selectionState.handle === segment.handleIn && !segment.handleOut.isZero()) {
              if (!event.modifiers.shift) {
                segment.handleOut = segment.handleIn.normalize().multiply(-segment.handleOut.length);
              } else {
                segment.handleOut = segment.handleIn.multiply(-1);
              }
            }
          }
        } else if (this.selectionState.segment != null) {
          if (g.getSnap() >= 1) {
            point = g.snap2D(event.point);
            segment.point.x = point.x;
            segment.point.y = point.y;
          } else {
            segment.point.x += event.delta.x;
            segment.point.y += event.delta.y;
          }
        }
        g.validatePosition(this, null, true);
        this.modifyPoint(segment, segment.point, segment.handleIn, segment.handleOut, true, false);
      };

      PrecisePath.prototype.endModifyPoint = function() {
        if (this.data.smooth) {
          this.controlPath.smooth();
        }
        this.draw();
        this.rasterize();
        this.selectionHighlight.bringToFront();
        this.update('points');
      };

      PrecisePath.prototype.modifyPointTypeCommand = function(rtype) {
        g.commandManager.add(new g.ModifyPointTypeCommand(this, this.selectionState.segment, rtype), true);
      };

      PrecisePath.prototype.modifySelectedPointType = function(value, update) {
        if (update == null) {
          update = true;
        }
        if (this.selectionState.segment == null) {
          return;
        }
        this.modifyPointType(this.selectionState.segment, value, update);
      };

      PrecisePath.prototype.modifyPointType = function(segment, rtype, update) {
        if (update == null) {
          update = true;
        }
        if (!Segment.prototype.isPrototypeOf(segment)) {
          segment = this.controlPath.segments[segment];
        }
        if (this.data.smooth) {
          return;
        }
        this.selectionState.segment.rtype = rtype;
        switch (rtype) {
          case 'corner':
            if (this.selectionState.segment.linear = true) {
              this.selectionState.segment.linear = false;
              this.selectionState.segment.handleIn = this.selectionState.segment.previous.point.subtract(this.selectionState.segment.point).multiply(0.5);
              this.selectionState.segment.handleOut = this.selectionState.segment.next.point.subtract(this.selectionState.segment.point).multiply(0.5);
            }
            break;
          case 'point':
            this.selectionState.segment.linear = true;
            break;
          case 'smooth':
            this.smoothPoint(this.selectionState.segment);
        }
        this.draw();
        this.highlightSelectedPoint();
        if (!this.socketAction) {
          if (update) {
            this.update('point');
          }
          g.chatSocket.emit("bounce", {
            itemPk: this.pk,
            "function": "modifyPointType",
            "arguments": [segment.index, rtype, false]
          });
        }
      };

      PrecisePath.prototype.modifyControlPathCommand = function(previousPointsAndPlanet, newPointsAndPlanet) {
        g.commandManager.add(new g.ModifyControlPathCommand(this, previousPointsAndPlanet, newPointsAndPlanet), false);
      };

      PrecisePath.prototype.modifyControlPath = function(pointsAndPlanet, update) {
        var fullySelected, selected;
        if (update == null) {
          update = true;
        }
        selected = this.controlPath.selected;
        fullySelected = this.controlPath.fullySelected;
        this.controlPath.removeSegments();
        this.setControlPath(pointsAndPlanet.points, pointsAndPlanet.planet);
        this.controlPath.selected = selected;
        if (fullySelected) {
          this.controlPath.fullySelected = true;
        }
        this.selectionState = {
          move: true
        };
        this.highlightSelectedPoint();
        this.draw();
        if (!this.socketAction) {
          if (update) {
            this.update('point');
          }
          g.chatSocket.emit("bounce", {
            itemPk: this.pk,
            "function": "modifyControlPath",
            "arguments": [pointsAndPlanet, false]
          });
        }
      };

      PrecisePath.prototype.setSmooth = function(smooth) {
        var previousPointsAndPlanet, segment, _i, _len, _ref;
        this.data.smooth = smooth;
        if (this.data.smooth) {
          previousPointsAndPlanet = this.getPointsAndPlanet();
          this.controlPath.smooth();
          this.controlPath.fullySelected = false;
          this.controlPath.selected = true;
          this.selectionState = {
            move: true
          };
          this.highlightSelectedPoint();
          _ref = this.controlPath.segments;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            segment = _ref[_i];
            segment.rtype = 'smooth';
          }
          this.draw();
          this.modifyControlPathCommand(previousPointsAndPlanet, this.getPointsAndPlanet());
        } else {
          this.controlPath.fullySelected = true;
        }
      };

      PrecisePath.prototype.simplifyControlPath = function() {
        var previousPointsAndPlanet, _ref;
        previousPointsAndPlanet = this.getPointsAndPlanet();
        if ((_ref = this.controlPath) != null) {
          _ref.simplify();
        }
        this.draw();
        this.update();
        this.modifyControlPathCommand(previousPointsAndPlanet, this.getPointsAndPlanet());
      };

      PrecisePath.prototype.setParameter = function(controller, value, updateGUI, update) {
        var _ref, _ref1;
        PrecisePath.__super__.setParameter.call(this, controller, value, updateGUI, update);
        switch (controller.name) {
          case 'showSelectionRectangle':
            if ((_ref = this.selectionRectangle) != null) {
              _ref.selected = this.data.showSelectionRectangle;
            }
            if ((_ref1 = this.selectionRectangle) != null) {
              _ref1.visible = this.data.showSelectionRectangle;
            }
        }
      };

      PrecisePath.prototype.remove = function() {
        var _ref;
        if ((_ref = this.canvasRaster) != null) {
          _ref.remove();
        }
        this.canvasRaster = null;
        PrecisePath.__super__.remove.call(this);
      };

      return PrecisePath;

    })(g.RPath);
    g.PrecisePath = PrecisePath;
    g.pathClasses = [];
    g.pathClasses.push(g.PrecisePath);
    SpeedPath = (function(_super) {
      __extends(SpeedPath, _super);

      function SpeedPath() {
        return SpeedPath.__super__.constructor.apply(this, arguments);
      }

      SpeedPath.rname = 'Speed path';

      SpeedPath.rdescription = "This path offers speed.";

      SpeedPath.iconURL = null;

      SpeedPath.iconAlt = null;

      SpeedPath.maxSpeed = 200;

      SpeedPath.speedStep = 20;

      SpeedPath.secureStep = 25;

      SpeedPath.initializeParameters = function() {
        var parameters;
        parameters = SpeedPath.__super__.constructor.initializeParameters.call(this);
        parameters['Edit curve'].showSpeed = {
          type: 'checkbox',
          label: 'Show speed',
          "default": false
        };
        if (g.wacomPenAPI != null) {
          parameters['Edit curve'].usePenPressure = {
            type: 'checkbox',
            label: 'Pen pressure',
            "default": true
          };
        }
        return parameters;
      };

      SpeedPath.parameters = SpeedPath.initializeParameters();

      SpeedPath.prototype.initializeDrawing = function(createCanvas) {
        if (createCanvas == null) {
          createCanvas = false;
        }
        this.speedOffset = 0;
        SpeedPath.__super__.initializeDrawing.call(this, createCanvas);
      };

      SpeedPath.prototype.loadPath = function(points) {
        if (this.data == null) {
          this.data = {};
        }
        this.speeds = this.data.speeds || [];
        SpeedPath.__super__.loadPath.call(this, points);
      };

      SpeedPath.prototype.checkUpdateDrawing = function(segment, redrawing) {
        var controlPathOffset, currentSpeed, f, previousControlPathOffset, previousSpeed, speed, step;
        if (redrawing == null) {
          redrawing = false;
        }
        if (redrawing) {
          SpeedPath.__super__.checkUpdateDrawing.call(this, segment, redrawing);
          return;
        }
        step = this.data.step;
        controlPathOffset = segment.location.offset;
        previousControlPathOffset = segment.previous != null ? segment.previous.location.offset : 0;
        previousSpeed = this.speeds.length > 0 ? this.speeds.pop() : 0;
        currentSpeed = null;
        if (!this.data.usePenPressure || g.wacomPointerType[g.wacomPenAPI.pointerType] === 'Mouse') {
          currentSpeed = controlPathOffset - previousControlPathOffset;
        } else {
          currentSpeed = g.wacomPenAPI.pressure * this.constructor.maxSpeed;
        }
        while (this.speedOffset + this.constructor.speedStep < controlPathOffset) {
          this.speedOffset += this.constructor.speedStep;
          f = (this.speedOffset - previousControlPathOffset) / currentSpeed;
          speed = g.linearInterpolation(previousSpeed, currentSpeed, f);
          this.speeds.push(Math.min(speed, this.constructor.maxSpeed));
        }
        this.speeds.push(Math.min(currentSpeed, this.constructor.maxSpeed));
        SpeedPath.__super__.checkUpdateDrawing.call(this, segment, redrawing);
      };

      SpeedPath.prototype.beginCreate = function(point, event) {
        this.speeds = this.data.polygonMode ? [this.constructor.maxSpeed / 3] : [];
        SpeedPath.__super__.beginCreate.call(this, point, event);
      };

      SpeedPath.prototype.endCreate = function(point, event) {
        SpeedPath.__super__.endCreate.call(this, point, event);
      };

      SpeedPath.prototype.computeSpeed = function() {
        var controlPathLength, currentAverageSpeed, currentOffset, distance, distances, f, i, interpolation, nextOffset, offset, point, pointOffset, previousDistance, previousOffset, previousPointOffset, previousSpeed, segment, speed, step, _i, _j, _len, _len1, _ref;
        step = this.constructor.speedStep;
        distances = [];
        controlPathLength = this.controlPath.length;
        currentOffset = step;
        segment = this.controlPath.firstSegment;
        distance = segment.point.getDistance(segment.next.point);
        distances.push({
          speed: distance,
          offset: 0
        });
        previousDistance = 0;
        pointOffset = 0;
        previousPointOffset = 0;
        _ref = this.controlPath.segments;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          segment = _ref[i];
          if (i === 0) {
            continue;
          }
          point = segment.point;
          previousDistance = distance;
          distance = point.getDistance(segment.previous.point);
          previousPointOffset = pointOffset;
          pointOffset += distance;
          while (pointOffset > currentOffset) {
            f = (currentOffset - previousPointOffset) / distance;
            interpolation = g.linearInterpolation(previousDistance, distance, f);
            distances.push({
              speed: interpolation,
              offset: currentOffset
            });
            currentOffset += step;
          }
          distances.push({
            speed: distance,
            offset: pointOffset
          });
        }
        distances.push({
          speed: distance,
          offset: currentOffset
        });
        this.speeds = [];
        nextOffset = step;
        speed = distances.first().speed;
        previousSpeed = speed;
        this.speeds.push(speed);
        offset = 0;
        previousOffset = offset;
        currentAverageSpeed = 0;
        for (i = _j = 0, _len1 = distances.length; _j < _len1; i = ++_j) {
          distance = distances[i];
          if (i === 0) {
            continue;
          }
          previousSpeed = speed;
          speed = distance.speed;
          previousOffset = offset;
          offset = distance.offset;
          currentAverageSpeed += ((speed + previousSpeed) / 2.0) * (offset - previousOffset) / step;
          if (offset === nextOffset) {
            this.speeds.push(Math.min(currentAverageSpeed, this.constructor.maxSpeed));
            currentAverageSpeed = 0;
            nextOffset += step;
          }
        }
      };

      SpeedPath.prototype.showSpeed = function() {
        var _ref, _ref1;
        if ((_ref = this.speedGroup) != null) {
          _ref.visible = this.data.showSpeed;
        }
        if ((this.speeds == null) || !this.data.showSpeed) {
          return;
        }
        if ((_ref1 = this.speedGroup) != null) {
          _ref1.bringToFront();
        }
      };

      SpeedPath.prototype.modifySpeed = function(speeds, update) {
        var _ref;
        this.speeds = speeds;
        this.updateSpeed();
        this.draw();
        if (!this.socketAction) {
          if (update) {
            this.update('speed');
          }
          g.chatSocket.emit("bounce", {
            itemPk: this.pk,
            "function": "modifySpeed",
            "arguments": [this.speeds, false]
          });
        } else {
          if ((_ref = this.speedGroup) != null) {
            _ref.visible = (this.selectionRectangle != null) && this.data.showSpeed;
          }
        }
      };

      SpeedPath.prototype.updateSpeed = function() {
        var alreadyExists, controlPathLength, handle, handlePoint, i, j, normal, normalNormalized, o, offset, point, s, speed, speedCurve, speedHandle, speedHandles, speedHandlesLengthM1, step, _i, _j, _len, _ref, _ref1, _ref2;
        if ((_ref = this.speedGroup) != null) {
          _ref.visible = this.data.showSpeed;
        }
        if ((this.speeds == null) || !this.data.showSpeed) {
          return;
        }
        step = this.constructor.speedStep;
        alreadyExists = this.speedGroup != null;
        if (alreadyExists) {
          this.speedGroup.bringToFront();
          speedCurve = this.speedGroup.firstChild;
        } else {
          this.speedGroup = new Group();
          this.speedGroup.name = "speed group";
          this.speedGroup.strokeWidth = 1;
          this.speedGroup.strokeColor = g.selectionBlue;
          this.speedGroup.controller = this;
          this.group.addChild(this.speedGroup);
          speedCurve = new Path();
          speedCurve.name = "speed curve";
          speedCurve.strokeWidth = 1;
          speedCurve.strokeColor = g.selectionBlue;
          speedCurve.controller = this;
          this.speedGroup.addChild(speedCurve);
          this.handleGroup = new Group();
          this.handleGroup.name = "speed handle group";
          this.speedGroup.addChild(this.handleGroup);
        }
        speedHandles = this.handleGroup.children;
        offset = 0;
        controlPathLength = this.controlPath.length;
        while ((this.speeds.length - 1) * step < controlPathLength) {
          this.speeds.push(this.speeds.last());
        }
        i = 0;
        _ref1 = this.speeds;
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          speed = _ref1[i];
          offset = i > 0 ? i * step : 0.1;
          o = offset < controlPathLength ? offset : controlPathLength - 0.1;
          point = this.controlPath.getPointAt(o);
          normalNormalized = this.controlPath.getNormalAt(o).normalize();
          normal = normalNormalized.multiply(this.speeds[i]);
          handlePoint = point.add(normal);
          if (alreadyExists && i < speedCurve.segments.length) {
            speedCurve.segments[i].point = handlePoint;
            speedHandles[i].position = handlePoint;
            speedHandles[i].rsegment.firstSegment.point = point;
            speedHandles[i].rsegment.lastSegment.point = handlePoint;
            speedHandles[i].rnormal = normalNormalized;
          } else {
            speedCurve.add(handlePoint);
            s = new Path();
            s.name = 'speed segment';
            s.strokeWidth = 1;
            s.strokeColor = g.selectionBlue;
            s.add(point);
            s.add(handlePoint);
            s.controller = this;
            this.speedGroup.addChild(s);
            handle = new Path.Rectangle(handlePoint.subtract(2), 4);
            handle.name = 'speed handle';
            handle.strokeWidth = 1;
            handle.strokeColor = g.selectionBlue;
            handle.fillColor = 'white';
            handle.rnormal = normalNormalized;
            handle.rindex = i;
            handle.rsegment = s;
            handle.controller = this;
            this.handleGroup.addChild(handle);
          }
          if (offset > controlPathLength) {
            break;
          }
        }
        if (offset > controlPathLength && i + 1 <= speedHandles.length - 1) {
          speedHandlesLengthM1 = speedHandles.length - 1;
          for (j = _j = _ref2 = i + 1; _ref2 <= speedHandlesLengthM1 ? _j <= speedHandlesLengthM1 : _j >= speedHandlesLengthM1; j = _ref2 <= speedHandlesLengthM1 ? ++_j : --_j) {
            speedHandle = this.handleGroup.lastChild;
            speedHandle.rsegment.remove();
            speedHandle.remove();
            speedCurve.lastSegment.remove();
          }
        }
      };

      SpeedPath.prototype.speedAt = function(offset) {
        var f, i;
        f = offset % this.constructor.speedStep;
        i = (offset - f) / this.constructor.speedStep;
        f /= this.constructor.speedStep;
        if (this.speeds != null) {
          if (i < this.speeds.length - 1) {
            return g.linearInterpolation(this.speeds[i], this.speeds[i + 1], f);
          } else {
            return this.speeds.last();
          }
        } else {
          this.constructor.maxSpeed / 2;
        }
      };

      SpeedPath.prototype.draw = function(simplified) {
        if (simplified == null) {
          simplified = false;
        }
        this.speedOffset = 0;
        SpeedPath.__super__.draw.call(this, simplified);
        if (this.controlPath.selected) {
          this.updateSpeed();
        }
      };

      SpeedPath.prototype.getData = function() {
        var data;
        delete this.data.usePenPressure;
        data = jQuery.extend({}, SpeedPath.__super__.getData.call(this));
        data.speeds = (this.speeds != null) && (this.handleGroup != null) ? this.speeds.slice(0, this.handleGroup.children.length + 1) : this.speeds;
        return data;
      };

      SpeedPath.prototype.select = function() {
        var _ref;
        if (!SpeedPath.__super__.select.call(this)) {
          return false;
        }
        this.showSpeed();
        if (this.data.showSpeed) {
          if (this.speedGroup == null) {
            this.updateSpeed();
          }
          if ((_ref = this.speedGroup) != null) {
            _ref.visible = true;
          }
        }
        return true;
      };

      SpeedPath.prototype.deselect = function() {
        var _ref;
        if (!SpeedPath.__super__.deselect.call(this)) {
          return false;
        }
        if ((_ref = this.speedGroup) != null) {
          _ref.visible = false;
        }
        return true;
      };

      SpeedPath.prototype.initializeSelection = function(event, hitResult) {
        var _ref;
        if ((_ref = this.speedSelectionHighlight) != null) {
          _ref.remove();
        }
        this.speedSelectionHighlight = null;
        if (hitResult.item.name === "speed handle") {
          this.selectionState = {
            speedHandle: hitResult.item
          };
          return;
        }
        SpeedPath.__super__.initializeSelection.call(this, event, hitResult);
      };

      SpeedPath.prototype.updateModifySpeed = function(event) {
        var delta, handle, handlePosition, handleToPoint, handlei, i, index, influence, influenceFactor, max, maxSpeed, n, newHandleToPoint, projection, projectionLength, sign, _i, _ref, _ref1;
        if (this.selectionState.speedHandle != null) {
          if ((_ref = this.speedSelectionHighlight) != null) {
            _ref.remove();
          }
          maxSpeed = this.constructor.maxSpeed;
          this.speedSelectionHighlight = new Path();
          this.speedSelectionHighlight.name = 'speed selection highlight';
          this.speedSelectionHighlight.strokeWidth = 1;
          this.speedSelectionHighlight.strokeColor = 'blue';
          this.speedGroup.addChild(this.speedSelectionHighlight);
          handle = this.selectionState.speedHandle;
          handlePosition = handle.bounds.center;
          handleToPoint = event.point.subtract(handlePosition);
          projection = handleToPoint.project(handle.rnormal);
          projectionLength = projection.length;
          sign = Math.sign(projection.x) === Math.sign(handle.rnormal.x) && Math.sign(projection.y) === Math.sign(handle.rnormal.y);
          sign = sign ? 1 : -1;
          this.speeds[handle.rindex] += sign * projectionLength;
          if (this.speeds[handle.rindex] < 0) {
            this.speeds[handle.rindex] = 0;
          } else if (this.speeds[handle.rindex] > maxSpeed) {
            this.speeds[handle.rindex] = maxSpeed;
          }
          newHandleToPoint = event.point.subtract(handle.position.add(projection));
          influenceFactor = newHandleToPoint.length / (this.constructor.speedStep * 3);
          max = g.gaussian(0, influenceFactor, 0);
          i = 1;
          influence = 1;
          while (influence > 0.1 && i < 20) {
            influence = g.gaussian(0, influenceFactor, i) / max;
            delta = projectionLength * influence;
            for (n = _i = -1; _i <= 1; n = _i += 2) {
              index = handle.rindex + n * i;
              if (index >= 0 && index < this.handleGroup.children.length) {
                handlei = this.handleGroup.children[index];
                this.speeds[index] += sign * delta;
                if (this.speeds[index] < 0) {
                  this.speeds[index] = 0;
                } else if (this.speeds[index] > maxSpeed) {
                  this.speeds[index] = maxSpeed;
                }
              }
            }
            i++;
          }
          this.speedSelectionHighlight.strokeColor.hue -= Math.min(240 * (influenceFactor / 10), 240);
          this.speedSelectionHighlight.add(handle.position.add(projection));
          this.speedSelectionHighlight.add(event.point);
          this.draw(true);
          if (this.selectionRectangle != null) {
            if ((_ref1 = this.selectionHighlight) != null) {
              _ref1.position = this.selectionState.segment.point;
            }
          }
        }
      };

      SpeedPath.prototype.endModifySpeed = function() {
        var _ref;
        this.draw();
        this.rasterize();
        this.update('speed');
        if ((_ref = this.speedSelectionHighlight) != null) {
          _ref.remove();
        }
        this.speedSelectionHighlight = null;
        if (!this.socketAction) {
          g.chatSocket.emit("bounce", {
            itemPk: this.pk,
            "function": "modifySpeed",
            "arguments": [this.speeds, false]
          });
        }
      };

      SpeedPath.prototype.remove = function() {
        this.speedGroup = null;
        SpeedPath.__super__.remove.call(this);
      };

      return SpeedPath;

    })(g.PrecisePath);
    g.SpeedPath = SpeedPath;
    ThicknessPath = (function(_super) {
      __extends(ThicknessPath, _super);

      function ThicknessPath() {
        return ThicknessPath.__super__.constructor.apply(this, arguments);
      }

      ThicknessPath.rname = 'Thickness path';

      ThicknessPath.rdescription = "The stroke width is function of the drawing speed: the faster the wider.";

      ThicknessPath.iconURL = 'static/images/icons/inverted/rollerBrush.png';

      ThicknessPath.iconAlt = 'roller brush';

      ThicknessPath.initializeParameters = function() {
        var parameters;
        parameters = ThicknessPath.__super__.constructor.initializeParameters.call(this);
        parameters['Style'].strokeWidth["default"] = 0;
        parameters['Style'].strokeColor.defaultCheck = false;
        parameters['Style'].fillColor.defaultCheck = true;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].step = {
          type: 'slider',
          label: 'Step',
          min: 30,
          max: 300,
          "default": 30,
          simplified: 30,
          step: 1
        };
        parameters['Parameters'].trackWidth = {
          type: 'slider',
          label: 'Track width',
          min: 0.1,
          max: 3,
          "default": 0.5
        };
        parameters['Parameters'].useCanvas = {
          type: 'checkbox',
          label: 'Use canvas',
          "default": false
        };
        return parameters;
      };

      ThicknessPath.parameters = ThicknessPath.initializeParameters();

      ThicknessPath.prototype.beginDraw = function() {
        this.initializeDrawing(false);
        this.path = this.addPath();
        this.path.add(this.controlPath.firstSegment.point);
        this.path.add(this.controlPath.firstSegment.point);
      };

      ThicknessPath.prototype.updateDraw = function(offset, step) {
        var bottom, delta, normal, point, speed, top;
        point = this.controlPath.getPointAt(offset);
        normal = this.controlPath.getNormalAt(offset).normalize();
        if (!step) {
          if (this.path.segments.length <= 1) {
            return;
          }
          this.path.firstSegment.point = point;
          return;
        }
        speed = this.speedAt(offset);
        delta = normal.multiply(speed * this.data.trackWidth / 2);
        top = point.add(delta);
        bottom = point.subtract(delta);
        this.path.firstSegment.remove();
        this.path.add(top);
        this.path.insert(0, bottom);
        this.path.insert(0, point);
        this.path.smooth();
      };

      ThicknessPath.prototype.endDraw = function() {
        this.path.add(this.controlPath.lastSegment.point);
        this.path.closed = true;
        this.path.smooth();
        this.path.selected = false;
      };

      return ThicknessPath;

    })(g.SpeedPath);
    g.ThicknessPath = ThicknessPath;
    g.pathClasses.push(g.ThicknessPath);
    Meander = (function(_super) {
      __extends(Meander, _super);

      function Meander() {
        return Meander.__super__.constructor.apply(this, arguments);
      }

      Meander.rname = 'Meander';

      Meander.rdescription = "As Karl Kerenyi pointed out, \"the meander is the figure of a labyrinth in linear form\".\nA meander or meandros (Greek: Μαίανδρος) is a decorative border constructed from a continuous line, shaped into a repeated motif.\nSuch a design is also called the Greek fret or Greek key design, although these are modern designations.\n(source: http://en.wikipedia.org/wiki/Meander_(art))";

      Meander.iconURL = 'static/images/icons/inverted/squareSpiral.png';

      Meander.iconAlt = 'square spiral';

      Meander.initializeParameters = function() {
        var parameters;
        parameters = Meander.__super__.constructor.initializeParameters.call(this);
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].step = {
          type: 'slider',
          label: 'Step',
          min: 10,
          max: 100,
          "default": 20,
          simplified: 20,
          step: 1
        };
        parameters['Parameters'].thickness = {
          type: 'slider',
          label: 'Thickness',
          min: 1,
          max: 30,
          "default": 5,
          step: 1
        };
        parameters['Parameters'].rsmooth = {
          type: 'checkbox',
          label: 'Smooth',
          "default": false
        };
        return parameters;
      };

      Meander.parameters = Meander.initializeParameters();

      Meander.prototype.beginDraw = function() {
        this.initializeDrawing(false);
        this.line = this.addPath();
        this.spiral = this.addPath();
      };

      Meander.prototype.updateDraw = function(offset, step) {
        var normal, p1, p2, p3, p4, p5, p6, p7, p8, p9, point, tangent;
        if (!step) {
          return;
        }
        point = this.controlPath.getPointAt(offset);
        normal = this.controlPath.getNormalAt(offset).normalize();
        tangent = normal.rotate(90);
        this.line.add(point);
        this.spiral.add(point.add(normal.multiply(this.data.thickness)));
        p1 = point.add(normal.multiply(this.data.step));
        this.spiral.add(p1);
        p2 = p1.add(tangent.multiply(this.data.step - this.data.thickness));
        this.spiral.add(p2);
        p3 = p2.add(normal.multiply(-(this.data.step - 2 * this.data.thickness)));
        this.spiral.add(p3);
        p4 = p3.add(tangent.multiply(-(this.data.step - 3 * this.data.thickness)));
        this.spiral.add(p4);
        p5 = p4.add(normal.multiply(this.data.thickness));
        this.spiral.add(p5);
        p6 = p5.add(tangent.multiply(this.data.step - 4 * this.data.thickness));
        this.spiral.add(p6);
        p7 = p6.add(normal.multiply(this.data.step - 4 * this.data.thickness));
        this.spiral.add(p7);
        p8 = p7.add(tangent.multiply(-(this.data.step - 3 * this.data.thickness)));
        this.spiral.add(p8);
        p9 = p8.add(normal.multiply(-(this.data.step - 2 * this.data.thickness)));
        this.spiral.add(p9);
      };

      Meander.prototype.endDraw = function() {
        if (this.data.rsmooth) {
          this.spiral.smooth();
          this.line.smooth();
        }
      };

      return Meander;

    })(g.PrecisePath);
    g.Meander = Meander;
    g.pathClasses.push(g.Meander);
    GridPath = (function(_super) {
      __extends(GridPath, _super);

      function GridPath() {
        return GridPath.__super__.constructor.apply(this, arguments);
      }

      GridPath.rname = 'Grid path';

      GridPath.rdescription = "Draws a grid along the path, the thickness of the grid being function of the speed of the drawing.";

      GridPath.initializeParameters = function() {
        var parameters;
        parameters = GridPath.__super__.constructor.initializeParameters.call(this);
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].step = {
          type: 'slider',
          label: 'Step',
          min: 5,
          max: 100,
          "default": 5,
          simplified: 20,
          step: 1
        };
        parameters['Parameters'].minWidth = {
          type: 'slider',
          label: 'Min width',
          min: 1,
          max: 100,
          "default": 5
        };
        parameters['Parameters'].maxWidth = {
          type: 'slider',
          label: 'Max width',
          min: 1,
          max: 250,
          "default": 200
        };
        parameters['Parameters'].minSpeed = {
          type: 'slider',
          label: 'Min speed',
          min: 1,
          max: 250,
          "default": 1
        };
        parameters['Parameters'].maxSpeed = {
          type: 'slider',
          label: 'Max speed',
          min: 1,
          max: 250,
          "default": 200
        };
        parameters['Parameters'].nLines = {
          type: 'slider',
          label: 'N lines',
          min: 1,
          max: 5,
          "default": 2,
          simplified: 2,
          step: 1
        };
        parameters['Parameters'].symmetric = {
          type: 'dropdown',
          label: 'Symmetry',
          values: ['symmetric', 'top', 'bottom'],
          "default": 'top'
        };
        parameters['Parameters'].speedForWidth = {
          type: 'checkbox',
          label: 'Speed for width',
          "default": true
        };
        parameters['Parameters'].speedForLength = {
          type: 'checkbox',
          label: 'Speed for length',
          "default": false
        };
        parameters['Parameters'].orthoLines = {
          type: 'checkbox',
          label: 'Orthogonal lines',
          "default": true
        };
        parameters['Parameters'].lengthLines = {
          type: 'checkbox',
          label: 'Length lines',
          "default": true
        };
        return parameters;
      };

      GridPath.parameters = GridPath.initializeParameters();

      GridPath.prototype.beginDraw = function() {
        var i, nLines, _i;
        this.initializeDrawing(false);
        if (this.data.lengthLines) {
          this.lines = [];
          nLines = this.data.nLines;
          if (this.data.symmetric === 'symmetric') {
            nLines *= 2;
          }
          for (i = _i = 1; 1 <= nLines ? _i <= nLines : _i >= nLines; i = 1 <= nLines ? ++_i : --_i) {
            this.lines.push(this.addPath());
          }
        }
        this.lastOffset = 0;
      };

      GridPath.prototype.updateDraw = function(offset, step) {
        var addPoint, midOffset, speed, stepOffset;
        if (!step) {
          return;
        }
        speed = this.speedAt(offset);
        addPoint = (function(_this) {
          return function(offset, speed) {
            var delta, divisor, i, line, normal, path, point, width, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
            point = _this.controlPath.getPointAt(offset);
            normal = _this.controlPath.getNormalAt(offset).normalize();
            if (_this.data.speedForWidth) {
              width = _this.data.minWidth + (_this.data.maxWidth - _this.data.minWidth) * speed / _this.constructor.maxSpeed;
            } else {
              width = _this.data.minWidth;
            }
            if (_this.data.lengthLines) {
              divisor = _this.data.nLines > 1 ? _this.data.nLines - 1 : 1;
              if (_this.data.symmetric === 'symmetric') {
                _ref = _this.lines;
                for (i = _i = 0, _len = _ref.length; _i < _len; i = _i += 2) {
                  line = _ref[i];
                  _this.lines[i + 0].add(point.add(normal.multiply(i * width * 0.5 / divisor)));
                  _this.lines[i + 1].add(point.add(normal.multiply(-i * width * 0.5 / divisor)));
                }
              } else {
                if (_this.data.symmetric === 'top') {
                  _ref1 = _this.lines;
                  for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                    line = _ref1[i];
                    line.add(point.add(normal.multiply(i * width / divisor)));
                  }
                } else if (_this.data.symmetric === 'bottom') {
                  _ref2 = _this.lines;
                  for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
                    line = _ref2[i];
                    line.add(point.add(normal.multiply(-i * width / divisor)));
                  }
                }
              }
            }
            if (_this.data.orthoLines) {
              path = _this.addPath();
              delta = normal.multiply(width);
              switch (_this.data.symmetric) {
                case 'symmetric':
                  path.add(point.add(delta));
                  path.add(point.subtract(delta));
                  break;
                case 'top':
                  path.add(point.add(delta));
                  path.add(point);
                  break;
                case 'bottom':
                  path.add(point.subtract(delta));
                  path.add(point);
              }
            }
          };
        })(this);
        if (!this.data.speedForLength) {
          addPoint(offset, speed);
        } else {
          speed = this.data.minSpeed + (speed / this.constructor.maxSpeed) * (this.data.maxSpeed - this.data.minSpeed);
          stepOffset = offset - this.lastOffset;
          if (stepOffset > speed) {
            midOffset = (offset + this.lastOffset) / 2;
            addPoint(midOffset, speed);
            this.lastOffset = offset;
          }
        }
      };

      GridPath.prototype.endDraw = function() {};

      return GridPath;

    })(g.SpeedPath);
    g.GridPath = GridPath;
    g.pathClasses.push(g.GridPath);
    GeometricLines = (function(_super) {
      __extends(GeometricLines, _super);

      function GeometricLines() {
        return GeometricLines.__super__.constructor.apply(this, arguments);
      }

      GeometricLines.rname = 'Geometric lines';

      GeometricLines.rdescription = "Draws a line between pair of points which are close enough.";

      GeometricLines.iconURL = 'static/images/icons/inverted/links.png';

      GeometricLines.iconAlt = 'links';

      GeometricLines.initializeParameters = function() {
        var parameters;
        parameters = GeometricLines.__super__.constructor.initializeParameters.call(this);
        parameters['Style'].strokeColor.defaultFunction = null;
        parameters['Style'].strokeColor["default"] = "rgba(39, 158, 224, 0.21)";
        delete parameters['Style'].fillColor;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].step = {
          type: 'slider',
          label: 'Step',
          min: 5,
          max: 100,
          "default": 11,
          simplified: 20,
          step: 1
        };
        parameters['Parameters'].distance = {
          type: 'slider',
          label: 'Distance',
          min: 5,
          max: 250,
          "default": 150,
          simplified: 100
        };
        return parameters;
      };

      GeometricLines.parameters = GeometricLines.initializeParameters();

      GeometricLines.prototype.beginDraw = function() {
        this.initializeDrawing(true);
        this.points = [];
      };

      GeometricLines.prototype.updateDraw = function(offset, step) {
        var distMax, normal, point, pt, _i, _len, _ref;
        if (!step) {
          return;
        }
        point = this.controlPath.getPointAt(offset);
        normal = this.controlPath.getNormalAt(offset).normalize();
        point = this.projectToRaster(point);
        this.points.push(point);
        distMax = this.data.distance * this.data.distance;
        _ref = this.points;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pt = _ref[_i];
          if (point.getDistance(pt, true) < distMax) {
            this.context.beginPath();
            this.context.moveTo(point.x, point.y);
            this.context.lineTo(pt.x, pt.y);
            this.context.stroke();
          }
        }
      };

      GeometricLines.prototype.endDraw = function() {};

      return GeometricLines;

    })(g.PrecisePath);
    g.GeometricLines = GeometricLines;
    g.pathClasses.push(g.GeometricLines);
    PaintBrush = (function(_super) {
      __extends(PaintBrush, _super);

      function PaintBrush() {
        return PaintBrush.__super__.constructor.apply(this, arguments);
      }

      PaintBrush.rname = 'Paint brush';

      PaintBrush.rdescription = "Paints a thick stroke with customable blur effects.";

      PaintBrush.iconURL = 'static/images/icons/inverted/brush.png';

      PaintBrush.iconAlt = 'brush';

      PaintBrush.initializeParameters = function() {
        var parameters;
        parameters = PaintBrush.__super__.constructor.initializeParameters.call(this);
        delete parameters['Style'].fillColor;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].step = {
          type: 'slider',
          label: 'Step',
          min: 1,
          max: 100,
          "default": 11,
          simplified: 20,
          step: 1
        };
        parameters['Parameters'].size = {
          type: 'slider',
          label: 'Size',
          min: 1,
          max: 100,
          "default": 10
        };
        parameters['Parameters'].blur = {
          type: 'slider',
          label: 'Blur',
          min: 0,
          max: 100,
          "default": 20
        };
        return parameters;
      };

      PaintBrush.parameters = PaintBrush.initializeParameters();

      PaintBrush.prototype.getDrawingBounds = function() {
        return this.getBounds().expand(this.data.size);
      };

      PaintBrush.prototype.beginDraw = function() {
        var point;
        this.initializeDrawing(true);
        point = this.controlPath.firstSegment.point;
        point = this.projectToRaster(point);
        this.context.moveTo(point.x, point.y);
      };

      PaintBrush.prototype.updateDraw = function(offset, step) {
        var endColor, innerRadius, midColor, normal, outerRadius, point, radialGradient;
        if (!step) {
          return;
        }
        point = this.controlPath.getPointAt(offset);
        normal = this.controlPath.getNormalAt(offset).normalize();
        point = this.projectToRaster(point);
        innerRadius = this.data.size * (1 - this.data.blur / 100);
        outerRadius = this.data.size;
        radialGradient = this.context.createRadialGradient(point.x, point.y, innerRadius, point.x, point.y, outerRadius);
        midColor = new Color(this.data.strokeColor);
        midColor.alpha = 0.5;
        endColor = new Color(this.data.strokeColor);
        endColor.alpha = 0;
        radialGradient.addColorStop(0, this.data.strokeColor);
        radialGradient.addColorStop(0.5, midColor.toCSS());
        radialGradient.addColorStop(1, endColor.toCSS());
        this.context.fillStyle = radialGradient;
        this.context.fillRect(point.x - outerRadius, point.y - outerRadius, 2 * outerRadius, 2 * outerRadius);
      };

      PaintBrush.prototype.endDraw = function() {};

      return PaintBrush;

    })(g.PrecisePath);
    g.PaintBrush = PaintBrush;
    g.pathClasses.push(g.PaintBrush);
    PaintGun = (function(_super) {
      __extends(PaintGun, _super);

      function PaintGun() {
        return PaintGun.__super__.constructor.apply(this, arguments);
      }

      PaintGun.rname = 'Paint gun';

      PaintGun.rdescription = "The stroke width is function of the drawing speed: the faster the wider.";

      PaintGun.initializeParameters = function() {
        var parameters;
        parameters = PaintGun.__super__.constructor.initializeParameters.call(this);
        delete parameters['Style'].fillColor;
        parameters['Edit curve'].showSpeed["default"] = false;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].step = {
          type: 'slider',
          label: 'Step',
          min: 1,
          max: 100,
          "default": 11,
          simplified: 20,
          step: 1
        };
        parameters['Parameters'].trackWidth = {
          type: 'slider',
          label: 'Track width',
          min: 0.1,
          max: 3,
          "default": 0.25
        };
        parameters['Parameters'].roundEnd = {
          type: 'checkbox',
          label: 'Round end',
          "default": false
        };
        parameters['Parameters'].inverseThickness = {
          type: 'checkbox',
          label: 'Inverse thickness',
          "default": false
        };
        return parameters;
      };

      PaintGun.parameters = PaintGun.initializeParameters();

      PaintGun.prototype.getDrawingBounds = function() {
        var width;
        width = 0;
        if (!this.data.inverseThickness) {
          width = this.speeds.max() * this.data.trackWidth / 2;
        } else {
          width = Math.max(this.maxSpeed - this.speeds.min(), 0) * this.data.trackWidth / 2;
        }
        return this.getBounds().expand(width);
      };

      PaintGun.prototype.beginDraw = function() {
        var point;
        this.initializeDrawing(true);
        point = this.controlPath.firstSegment.point;
        point = this.projectToRaster(point);
        this.context.moveTo(point.x, point.y);
        this.previousTop = point;
        this.previousBottom = point;
        this.previousMidTop = point;
        this.previousMidBottom = point;
        this.maxSpeed = this.speeds.length > 0 ? this.speeds.max() / 1.5 : this.constructor.maxSpeed / 6;
      };

      PaintGun.prototype.drawStep = function(offset, step, end) {
        var bottom, delta, midBottom, midTop, normal, point, speed, top;
        if (end == null) {
          end = false;
        }
        point = this.controlPath.getPointAt(offset);
        normal = this.controlPath.getNormalAt(offset).normalize();
        speed = this.speedAt(offset);
        point = this.projectToRaster(point);
        if (!this.data.inverseThickness) {
          delta = normal.multiply(speed * this.data.trackWidth / 2);
        } else {
          delta = normal.multiply(Math.max(this.maxSpeed - speed, 0) * this.data.trackWidth / 2);
        }
        top = point.add(delta);
        bottom = point.subtract(delta);
        if (!end) {
          midTop = this.previousTop.add(top).multiply(0.5);
          midBottom = this.previousBottom.add(bottom).multiply(0.5);
        } else {
          midTop = top;
          midBottom = bottom;
        }
        this.context.fillStyle = this.data.strokeColor;
        this.context.beginPath();
        this.context.moveTo(this.previousMidTop.x, this.previousMidTop.y);
        this.context.lineTo(this.previousMidBottom.x, this.previousMidBottom.y);
        this.context.quadraticCurveTo(this.previousBottom.x, this.previousBottom.y, midBottom.x, midBottom.y);
        this.context.lineTo(midTop.x, midTop.y);
        this.context.quadraticCurveTo(this.previousTop.x, this.previousTop.y, this.previousMidTop.x, this.previousMidTop.y);
        this.context.fill();
        this.context.stroke();
        if (step) {
          this.previousTop = top;
          this.previousBottom = bottom;
          this.previousMidTop = midTop;
          this.previousMidBottom = midBottom;
        }
      };

      PaintGun.prototype.updateDraw = function(offset, step) {
        this.drawStep(offset, step);
      };

      PaintGun.prototype.endDraw = function() {
        var point;
        this.drawStep(this.controlPath.length, false, true);
        if (this.data.roundEnd) {
          point = this.controlPath.lastSegment.point;
          point = this.projectToRaster(point);
          this.context.beginPath();
          this.context.fillStyle = this.data.strokeColor;
          this.context.arc(point.x, point.y, this.speeds.last() * this.data.trackWidth / 2, 0, 2 * Math.PI);
          this.context.fill();
        }
      };

      return PaintGun;

    })(g.SpeedPath);
    g.PaintGun = PaintGun;
    g.pathClasses.push(g.PaintGun);
    DynamicBrush = (function(_super) {
      __extends(DynamicBrush, _super);

      function DynamicBrush() {
        this.onFrame = __bind(this.onFrame, this);
        return DynamicBrush.__super__.constructor.apply(this, arguments);
      }

      DynamicBrush.rname = 'Dynamic brush';

      DynamicBrush.rdescription = "The stroke width is function of the drawing speed: the faster the wider.";

      DynamicBrush.polygonMode = false;

      DynamicBrush.initializeParameters = function() {
        var parameters;
        parameters = DynamicBrush.__super__.constructor.initializeParameters.call(this);
        delete parameters['Style'].fillColor;
        parameters['Edit curve'].showSpeed["default"] = false;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].step = {
          type: 'slider',
          label: 'Step',
          min: 1,
          max: 100,
          "default": 5,
          simplified: 20,
          step: 1
        };
        parameters['Parameters'].trackWidth = {
          type: 'slider',
          label: 'Track width',
          min: 0.0,
          max: 10.0,
          "default": 0.5
        };
        parameters['Parameters'].mass = {
          type: 'slider',
          label: 'Mass',
          min: 1,
          max: 200,
          "default": 40
        };
        parameters['Parameters'].drag = {
          type: 'slider',
          label: 'Drag',
          min: 0,
          max: 0.4,
          "default": 0.1
        };
        parameters['Parameters'].maxSpeed = {
          type: 'slider',
          label: 'Max speed',
          min: 0,
          max: 100,
          "default": 35
        };
        parameters['Parameters'].roundEnd = {
          type: 'checkbox',
          label: 'Round end',
          "default": false
        };
        parameters['Parameters'].inverseThickness = {
          type: 'checkbox',
          label: 'Inverse thickness',
          "default": false
        };
        parameters['Parameters'].fixedAngle = {
          type: 'checkbox',
          label: 'Fixed angle',
          "default": false
        };
        parameters['Parameters'].simplify = {
          type: 'checkbox',
          label: 'Simplify',
          "default": true
        };
        parameters['Parameters'].angle = {
          type: 'slider',
          label: 'Angle',
          min: 0,
          max: 360,
          "default": 0
        };
        return parameters;
      };

      DynamicBrush.prototype.getDrawingBounds = function() {
        var width;
        width = this.data.inverseThickness ? this.speeds.max() : this.speeds.min();
        width = this.data.inverseThickness ? width : this.data.maxSpeed - width;
        width *= this.data.trackWidth;
        return this.getBounds().expand(2 * width);
      };

      DynamicBrush.prototype.beginDraw = function(redrawing) {
        if (redrawing == null) {
          redrawing = false;
        }
        this.initializeDrawing(true);
        this.point = this.controlPath.firstSegment.point;
        this.currentPosition = this.point;
        this.previousPosition = this.currentPosition;
        this.previousMidPosition = this.currentPosition;
        this.previousMidDelta = new Point();
        this.previousDelta = new Point();
        this.context.fillStyle = 'black';
        this.context.strokeStyle = this.data.fillColor;
        if (!redrawing) {
          this.velocity = new Point();
          this.velocities = [];
          this.controlPathReplacement = this.controlPath.clone();
          this.setAnimated(true);
        }
      };

      DynamicBrush.prototype.drawSegment = function(currentPosition, width, delta) {
        var midBottom, midDelta, midPosition, midTop, previousBottom, previousMidBottom, previousMidTop, previousTop;
        if (delta == null) {
          delta = null;
        }
        width = this.data.inverseThickness ? width : this.data.maxSpeed - width;
        width *= this.data.trackWidth;
        if (width < 0.1) {
          width = 0.1;
        }
        if (this.data.fixedAngle) {
          delta = new Point(1, 0);
          delta.angle = this.data.angle;
        } else {
          delta = delta.normalize();
        }
        delta = delta.multiply(width);
        midPosition = currentPosition.add(this.previousPosition).divide(2);
        midDelta = delta.add(this.previousDelta).divide(2);
        previousMidTop = this.projectToRaster(this.previousMidPosition.add(this.previousMidDelta));
        previousMidBottom = this.projectToRaster(this.previousMidPosition.subtract(this.previousMidDelta));
        previousTop = this.projectToRaster(this.previousPosition.add(this.previousDelta));
        previousBottom = this.projectToRaster(this.previousPosition.subtract(this.previousDelta));
        midTop = this.projectToRaster(midPosition.add(midDelta));
        midBottom = this.projectToRaster(midPosition.subtract(midDelta));
        this.context.beginPath();
        this.context.moveTo(previousMidTop.x, previousMidTop.y);
        this.context.lineTo(previousMidBottom.x, previousMidBottom.y);
        this.context.quadraticCurveTo(previousBottom.x, previousBottom.y, midBottom.x, midBottom.y);
        this.context.lineTo(midTop.x, midTop.y);
        this.context.quadraticCurveTo(previousTop.x, previousTop.y, previousMidTop.x, previousMidTop.y);
        this.context.fill();
        this.context.stroke();
        this.previousDelta = delta;
        this.previousMidPosition = midPosition;
        this.previousMidDelta = midDelta;
      };

      DynamicBrush.prototype.updateForce = function() {
        var acceleration, force;
        force = this.point.subtract(this.currentPosition);
        if (force.length < 0.1) {
          return false;
        }
        acceleration = force.divide(this.data.mass);
        this.velocity = this.velocity.add(acceleration);
        if (this.velocity.length < 0.1) {
          return false;
        }
        this.velocity = this.velocity.multiply(1.0 - this.data.drag);
        this.previousPosition = this.currentPosition;
        this.currentPosition = this.currentPosition.add(this.velocity);
        return true;
      };

      DynamicBrush.prototype.drawStep = function() {
        var continueDrawing, v;
        if (this.finishedDrawing) {
          return;
        }
        continueDrawing = this.updateForce();
        if (!continueDrawing) {
          return;
        }
        v = this.velocity.length;
        this.controlPathReplacement.add(this.currentPosition);
        this.velocities.push(v);
        this.drawSegment(this.currentPosition, v, new Point(-this.velocity.y, this.velocity.x));

        /*
        			width = if @data.inverseThickness then v else (10-v)
        			width *= @data.trackWidth
        
        			if not @data.fixedAngle
        				delta = new Point(-@velocity.y, @velocity.x)
        			else
        				delta = new Point(1,0)
        				delta.angle = @data.angle
        			delta = delta.normalize().multiply(width)
        
        			a = @projectToRaster(@previousPosition.add(@previousDelta))
        			b = @projectToRaster(@previousPosition.subtract(@previousDelta))
        			c = @projectToRaster(@currentPosition.subtract(delta))
        			d = @projectToRaster(@currentPosition.add(delta))
        
        			 * @path.add(c)
        			 * @path.insert(0, d)
         */
      };

      DynamicBrush.prototype.onFrame = function() {
        var i, _i;
        for (i = _i = 0; _i <= 2; i = ++_i) {
          this.drawStep();
        }
      };

      DynamicBrush.prototype.updateDraw = function(offset, step, redrawing) {
        var v;
        this.point = this.controlPath.getPointAt(offset);
        if (redrawing) {
          v = this.speedAt(offset);
          this.drawSegment(this.point, v, this.controlPath.getNormalAt(offset));
          this.previousPosition = this.point;

          /*
          				width = if @data.inverseThickness then v else (10-v)
          				width *= @data.trackWidth
          
          				if not @data.fixedAngle
          					delta = @controlPath.getNormalAt(offset).normalize()
          				else
          					delta = new Point(1,0)
          					delta.angle = @data.angle
          
          				delta = delta.multiply(width)
          				top = @point.add(delta)
          				bottom = @point.subtract(delta)
          
          				@path.add(top)
          				@path.insert(0, bottom)
           */
        }
      };

      DynamicBrush.prototype.endDraw = function(redrawing) {
        var f, i, length, location, offset;
        if (redrawing == null) {
          redrawing = false;
        }
        if (!redrawing) {
          this.setAnimated(false);
          this.finishedDrawing = true;
          length = this.controlPathReplacement.length;
          offset = 0;
          this.speeds = [];
          while (offset < length) {
            location = this.controlPathReplacement.getLocationAt(offset);
            i = location.segment.index;
            f = location.parameter;
            if (i < this.velocities.length - 1) {
              this.speeds.push(g.linearInterpolation(this.velocities[i], this.velocities[i + 1], f));
            } else {
              this.speeds.push(this.velocities[i]);
            }
            offset += this.constructor.speedStep;
          }
          this.velocities = [];
          if (this.data.simplify) {
            this.controlPathReplacement.simplify();
          }
          this.controlPathReplacement.insert(0, this.controlPathReplacement.firstSegment.point);
          this.controlPathReplacement.insert(0, this.controlPathReplacement.firstSegment.point);
          this.controlPath.segments = this.controlPathReplacement.segments;
          this.controlPathReplacement.remove();
        }
      };

      DynamicBrush.prototype.remove = function() {
        clearInterval(this.timerId);
        DynamicBrush.__super__.remove.call(this);
      };

      return DynamicBrush;

    })(g.SpeedPath);
    g.DynamicBrush = DynamicBrush;
    g.pathClasses.push(g.DynamicBrush);
    ShapePath = (function(_super) {
      __extends(ShapePath, _super);

      function ShapePath() {
        return ShapePath.__super__.constructor.apply(this, arguments);
      }

      ShapePath.rname = 'Shape path';

      ShapePath.rdescription = "Draws rectangles or ellipses along the path. The size of the shapes is function of the drawing speed.";

      ShapePath.initializeParameters = function() {
        var parameters;
        parameters = ShapePath.__super__.constructor.initializeParameters.call(this);
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].step = {
          type: 'slider',
          label: 'Step',
          min: 5,
          max: 100,
          "default": 20,
          simplified: 20,
          step: 1
        };
        parameters['Parameters'].ellipse = {
          type: 'checkbox',
          label: 'Ellipse',
          "default": false
        };
        parameters['Parameters'].minWidth = {
          type: 'slider',
          label: 'Min width',
          min: 1,
          max: 250,
          "default": 1
        };
        parameters['Parameters'].maxWidth = {
          type: 'slider',
          label: 'Max width',
          min: 1,
          max: 250,
          "default": 200
        };
        parameters['Parameters'].speedForLength = {
          type: 'checkbox',
          label: 'Speed for length',
          "default": false
        };
        parameters['Parameters'].minSpeed = {
          type: 'slider',
          label: 'Min speed',
          min: 1,
          max: 250,
          "default": 1
        };
        parameters['Parameters'].maxSpeed = {
          type: 'slider',
          label: 'Max speed',
          min: 1,
          max: 250,
          "default": 200
        };
        return parameters;
      };

      ShapePath.parameters = ShapePath.initializeParameters();

      ShapePath.prototype.beginDraw = function() {
        this.initializeDrawing(false);
        this.lastOffset = 0;
      };

      ShapePath.prototype.updateDraw = function(offset, step) {
        var addShape, midOffset, speed, stepOffset;
        if (!step) {
          return;
        }
        speed = this.speedAt(offset);
        addShape = (function(_this) {
          return function(offset, height, speed) {
            var normal, point, rectangle, shape, width;
            point = _this.controlPath.getPointAt(offset);
            normal = _this.controlPath.getNormalAt(offset);
            width = _this.data.minWidth + (_this.data.maxWidth - _this.data.minWidth) * speed / _this.constructor.maxSpeed;
            rectangle = new Rectangle(point.subtract(new Point(width / 2, height / 2)), new Size(width, height));
            if (!_this.data.ellipse) {
              shape = _this.addPath(new Path.Rectangle(rectangle));
            } else {
              shape = _this.addPath(new Path.Ellipse(rectangle));
            }
            shape.rotation = normal.angle;
          };
        })(this);
        if (!this.data.speedForLength) {
          addShape(offset, this.data.step, speed);
        } else {
          speed = this.data.minSpeed + (speed / this.constructor.maxSpeed) * (this.data.maxSpeed - this.data.minSpeed);
          stepOffset = offset - this.lastOffset;
          if (stepOffset > speed) {
            midOffset = (offset + this.lastOffset) / 2;
            addShape(midOffset, stepOffset, speed);
            this.lastOffset = offset;
          }
        }
      };

      ShapePath.prototype.endDraw = function() {};

      return ShapePath;

    })(g.SpeedPath);
    g.ShapePath = ShapePath;
    g.pathClasses.push(g.ShapePath);
    RShape = (function(_super) {
      __extends(RShape, _super);

      function RShape() {
        return RShape.__super__.constructor.apply(this, arguments);
      }

      RShape.Shape = paper.Path.Rectangle;

      RShape.rname = 'Shape';

      RShape.rdescription = "Base shape class";

      RShape.squareByDefault = true;

      RShape.centerByDefault = false;

      RShape.prototype.prepareHitTest = function(fullySelected, strokeWidth) {
        if (fullySelected == null) {
          fullySelected = true;
        }
        this.controlPath.fillColor = 'red';
        return RShape.__super__.prepareHitTest.call(this, fullySelected, strokeWidth);
      };

      RShape.prototype.finishHitTest = function(fullySelected) {
        if (fullySelected == null) {
          fullySelected = true;
        }
        this.controlPath.fillColor = null;
        return RShape.__super__.finishHitTest.call(this, fullySelected);
      };

      RShape.prototype.loadPath = function(points) {
        var distanceMax, i, point, _i, _len;
        if (this.data.rectangle == null) {
          console.log('Error loading shape ' + this.pk + ': invalid rectangle.');
        }
        this.rectangle = this.data.rectangle != null ? new Rectangle(this.data.rectangle) : new Rectangle();
        this.initializeControlPath();
        this.controlPath.rotation = this.rotation;
        this.initialize();
        g.rasterizer.loadItem(this);
        distanceMax = this.constructor.secureDistance * this.constructor.secureDistance;
        for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
          point = points[i];
          this.controlPath.segments[i].point === point;
          if (this.controlPath.segments[i].point.getDistance(point, true) > distanceMax) {
            this.controlPath.strokeColor = 'red';
            view.center = this.controlPath.bounds.center;
            console.log("Error: invalid shape!");
            return;
          }
        }
      };

      RShape.prototype.createShape = function() {
        this.shape = this.addPath(new this.constructor.Shape(this.rectangle));
      };

      RShape.prototype.draw = function(simplified) {
        var error, process;
        if (simplified == null) {
          simplified = false;
        }
        this.drawn = false;
        if (!g.rasterizer.requestDraw(this, simplified)) {
          return;
        }
        process = (function(_this) {
          return function() {
            _this.initializeDrawing();
            _this.createShape();
            _this.drawing.rotation = _this.rotation;
          };
        })(this);
        if (!g.catchErrors) {
          process();
        } else {
          try {
            process();
          } catch (_error) {
            error = _error;
            console.error(error.stack);
            console.error(error);
            throw error;
          }
        }
        this.drawn = true;
      };

      RShape.prototype.initializeControlPath = function(pointA, pointB, shift, specialKey) {
        var center, createFromCenter, delta, height, min, square, width, _ref;
        if (pointA && pointB) {
          square = this.constructor.squareByDefault ? !shift : shift;
          createFromCenter = this.constructor.centerByDefault ? !specialKey : specialKey;
          if (createFromCenter) {
            delta = pointB.subtract(pointA);
            this.rectangle = new Rectangle(pointA.subtract(delta), pointB);
            if (square) {
              center = this.rectangle.center;
              if (this.rectangle.width > this.rectangle.height) {
                this.rectangle.width = this.rectangle.height;
              } else {
                this.rectangle.height = this.rectangle.width;
              }
              this.rectangle.center = center;
            }
          } else {
            if (!square) {
              this.rectangle = new Rectangle(pointA, pointB);
            } else {
              width = pointA.x - pointB.x;
              height = pointA.y - pointB.y;
              min = Math.min(Math.abs(width), Math.abs(height));
              this.rectangle = new Rectangle(pointA, pointA.subtract(g.sign(width) * min, g.sign(height) * min));
            }
          }
        }
        if ((_ref = this.controlPath) != null) {
          _ref.remove();
        }
        if (this.rotation == null) {
          this.rotation = 0;
        }
        this.addControlPath(new Path.Rectangle(this.rectangle));
        this.controlPath.fillColor = g.selectionBlue;
        this.controlPath.fillColor.alpha = 0.25;
      };

      RShape.prototype.beginCreate = function(point, event) {
        var _ref;
        RShape.__super__.beginCreate.call(this);
        this.downPoint = point;
        this.initializeControlPath(this.downPoint, point, event != null ? (_ref = event.modifiers) != null ? _ref.shift : void 0 : void 0, g.specialKey(event));
      };

      RShape.prototype.updateCreate = function(point, event) {
        var _ref;
        this.initializeControlPath(this.downPoint, point, event != null ? (_ref = event.modifiers) != null ? _ref.shift : void 0 : void 0, g.specialKey(event));
        this.draw();
      };

      RShape.prototype.endCreate = function(point, event) {
        var _ref;
        this.initializeControlPath(this.downPoint, point, event != null ? (_ref = event.modifiers) != null ? _ref.shift : void 0 : void 0, g.specialKey(event));
        this.draw();
        RShape.__super__.endCreate.call(this);
      };

      RShape.prototype.setRectangle = function(event, update) {
        g.updatePathRectangle(this.controlPath, this.rectangle);
        RShape.__super__.setRectangle.call(this, event, update);
      };

      RShape.prototype.getData = function() {
        var data;
        data = jQuery.extend({}, this.data);
        data.rectangle = {
          x: this.rectangle.x,
          y: this.rectangle.y,
          width: this.rectangle.width,
          height: this.rectangle.height
        };
        return data;
      };

      return RShape;

    })(g.RPath);
    g.RShape = RShape;
    RectangleShape = (function(_super) {
      __extends(RectangleShape, _super);

      function RectangleShape() {
        return RectangleShape.__super__.constructor.apply(this, arguments);
      }

      RectangleShape.Shape = paper.Path.Rectangle;

      RectangleShape.category = 'Shape';

      RectangleShape.rname = 'Rectangle';

      RectangleShape.rdescription = "Simple rectangle, square by default (use shift key to draw a rectangle) which can have rounded corners.\nUse special key (command on a mac, control otherwise) to center the shape on the first point.";

      RectangleShape.iconURL = 'static/images/icons/inverted/rectangle.png';

      RectangleShape.iconAlt = 'rectangle';

      RectangleShape.initializeParameters = function() {
        var parameters;
        parameters = RectangleShape.__super__.constructor.initializeParameters.call(this);
        if (parameters['Style'] == null) {
          parameters['Style'] = {};
        }
        parameters['Style'].cornerRadius = {
          type: 'slider',
          label: 'Corner radius',
          min: 0,
          max: 100,
          "default": 0
        };
        return parameters;
      };

      RectangleShape.parameters = RectangleShape.initializeParameters();

      RectangleShape.prototype.createShape = function() {
        this.shape = this.addPath(new this.constructor.Shape(this.rectangle, this.data.cornerRadius));
      };

      return RectangleShape;

    })(g.RShape);
    g.RectangleShape = RectangleShape;
    g.pathClasses.push(g.RectangleShape);
    EllipseShape = (function(_super) {
      __extends(EllipseShape, _super);

      function EllipseShape() {
        return EllipseShape.__super__.constructor.apply(this, arguments);
      }

      EllipseShape.Shape = paper.Path.Ellipse;

      EllipseShape.category = 'Shape';

      EllipseShape.rname = 'Ellipse';

      EllipseShape.rdescription = "Simple ellipse, circle by default (use shift key to draw an ellipse).\nUse special key (command on a mac, control otherwise) to avoid the shape to be centered on the first point.";

      EllipseShape.iconURL = 'static/images/icons/inverted/circle.png';

      EllipseShape.iconAlt = 'circle';

      EllipseShape.squareByDefault = true;

      EllipseShape.centerByDefault = true;

      return EllipseShape;

    })(g.RShape);
    g.EllipseShape = EllipseShape;
    g.pathClasses.push(g.EllipseShape);
    StarShape = (function(_super) {
      __extends(StarShape, _super);

      function StarShape() {
        this.onFrame = __bind(this.onFrame, this);
        return StarShape.__super__.constructor.apply(this, arguments);
      }

      StarShape.Shape = paper.Path.Star;

      StarShape.category = 'Shape/Animated';

      StarShape.rname = 'Star';

      StarShape.rdescription = "Draws a star which can be animated (the color changes and it rotates).";

      StarShape.iconURL = 'static/images/icons/inverted/star.png';

      StarShape.iconAlt = 'star';

      StarShape.initializeParameters = function() {
        var parameters;
        parameters = StarShape.__super__.constructor.initializeParameters.call(this);
        if (parameters['Style'] == null) {
          parameters['Style'] = {};
        }
        parameters['Style'].nPoints = {
          type: 'slider',
          label: 'N points',
          min: 1,
          max: 100,
          "default": 5,
          step: 1
        };
        parameters['Style'].internalRadius = {
          type: 'slider',
          label: 'Internal radius',
          min: -200,
          max: 100,
          "default": 38
        };
        parameters['Style'].rsmooth = {
          type: 'checkbox',
          label: 'Smooth',
          "default": false
        };
        parameters['Style'].animate = {
          type: 'checkbox',
          label: 'Animate',
          "default": false
        };
        return parameters;
      };

      StarShape.parameters = StarShape.initializeParameters();

      StarShape.prototype.initialize = function() {
        this.setAnimated(this.data.animate);
      };

      StarShape.prototype.createShape = function() {
        var externalRadius, internalRadius, rectangle;
        rectangle = this.rectangle;
        if (this.data.internalRadius > -100) {
          externalRadius = rectangle.width / 2;
          internalRadius = externalRadius * this.data.internalRadius / 100;
        } else {
          internalRadius = rectangle.width / 2;
          externalRadius = internalRadius * 100 / this.data.internalRadius;
        }
        this.shape = this.addPath(new this.constructor.Shape(rectangle.center, this.data.nPoints, externalRadius, internalRadius));
        if (this.data.rsmooth) {
          this.shape.smooth();
        }
      };

      StarShape.prototype.onFrame = function(event) {
        this.shape.strokeColor.hue += 1;
        this.shape.rotation += 1;
      };

      return StarShape;

    })(g.RShape);
    g.StarShape = StarShape;
    g.pathClasses.push(g.StarShape);
    SpiralShape = (function(_super) {
      __extends(SpiralShape, _super);

      function SpiralShape() {
        this.onFrame = __bind(this.onFrame, this);
        return SpiralShape.__super__.constructor.apply(this, arguments);
      }

      SpiralShape.Shape = paper.Path.Ellipse;

      SpiralShape.category = 'Shape/Animated/Spiral';

      SpiralShape.rname = 'Spiral';

      SpiralShape.rdescription = "The spiral shape can have an intern radius, and a custom number of sides.";

      SpiralShape.iconURL = 'static/images/icons/inverted/spiral.png';

      SpiralShape.iconAlt = 'spiral';

      SpiralShape.initializeParameters = function() {
        var parameters;
        parameters = SpiralShape.__super__.constructor.initializeParameters.call(this);
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].minRadius = {
          type: 'slider',
          label: 'Minimum radius',
          min: 0,
          max: 100,
          "default": 0
        };
        parameters['Parameters'].nTurns = {
          type: 'slider',
          label: 'Number of turns',
          min: 1,
          max: 50,
          "default": 10
        };
        parameters['Parameters'].nSides = {
          type: 'slider',
          label: 'Sides',
          min: 3,
          max: 100,
          "default": 50
        };
        parameters['Parameters'].animate = {
          type: 'checkbox',
          label: 'Animate',
          "default": false
        };
        parameters['Parameters'].rotationSpeed = {
          type: 'slider',
          label: 'Rotation speed',
          min: -10,
          max: 10,
          "default": 1
        };
        return parameters;
      };

      SpiralShape.parameters = SpiralShape.initializeParameters();

      SpiralShape.prototype.initialize = function() {
        this.setAnimated(this.data.animate);
      };

      SpiralShape.prototype.createShape = function() {
        var angle, angleStep, c, hh, hw, i, radiusStepX, radiusStepY, rectangle, spiralHeight, spiralWidth, step, _i, _j, _ref, _ref1;
        this.shape = this.addPath();
        rectangle = this.rectangle;
        hw = rectangle.width / 2;
        hh = rectangle.height / 2;
        c = rectangle.center;
        angle = 0;
        angleStep = 360.0 / this.data.nSides;
        spiralWidth = hw - hw * this.data.minRadius / 100.0;
        spiralHeight = hh - hh * this.data.minRadius / 100.0;
        radiusStepX = (spiralWidth / this.data.nTurns) / this.data.nSides;
        radiusStepY = (spiralHeight / this.data.nTurns) / this.data.nSides;
        for (i = _i = 0, _ref = this.data.nTurns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          for (step = _j = 0, _ref1 = this.data.nSides - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; step = 0 <= _ref1 ? ++_j : --_j) {
            this.shape.add(new Point(c.x + hw * Math.cos(angle), c.y + hh * Math.sin(angle)));
            angle += 2.0 * Math.PI * angleStep / 360.0;
            hw -= radiusStepX;
            hh -= radiusStepY;
          }
        }
        this.shape.add(new Point(c.x + hw * Math.cos(angle), c.y + hh * Math.sin(angle)));
        this.shape.pivot = this.rectangle.center;
      };

      SpiralShape.prototype.onFrame = function(event) {
        this.shape.strokeColor.hue += 1;
        this.shape.rotation += this.rotationSpeed;
      };

      return SpiralShape;

    })(g.RShape);
    g.SpiralShape = SpiralShape;
    g.pathClasses.push(g.SpiralShape);
    Checkpoint = (function(_super) {
      __extends(Checkpoint, _super);

      function Checkpoint() {
        return Checkpoint.__super__.constructor.apply(this, arguments);
      }

      Checkpoint.Shape = paper.Path.Rectangle;

      Checkpoint.rname = 'Checkpoint';

      Checkpoint.rdescription = "Draw checkpoints on a lock with a Racer to create a race\n(the players must go through each checkpoint as fast as possible, with the car tool).";

      Checkpoint.category = 'Video game/Racer';

      Checkpoint.squareByDefault = false;

      Checkpoint.initializeParameters = function() {
        return {};
      };

      Checkpoint.parameters = Checkpoint.initializeParameters();

      Checkpoint.prototype.initialize = function() {
        var _base;
        this.data.type = 'checkpoint';
        if (this.lock != null) {
          if (this.lock.checkpoints.indexOf(this) < 0) {
            this.lock.checkpoints.push(this);
          }
          if ((_base = this.data).checkpointNumber == null) {
            _base.checkpointNumber = this.game.checkpoints.indexOf(this);
          }
        } else {
          g.romanesco_alert('A checkpoint must be placed on a lock', 'error');
          this.remove();
        }
      };

      Checkpoint.prototype.createShape = function() {
        this.data.strokeColor = 'rgb(150,30,30)';
        this.data.fillColor = null;
        this.shape = this.addPath(new Path.Rectangle(this.rectangle));
        this.text = this.addPath(new PointText(this.rectangle.center.add(0, 4)));
        this.text.content = this.data.checkpointNumber != null ? 'Checkpoint ' + this.data.checkpointNumber : 'Checkpoint';
        this.text.justification = 'center';
      };

      Checkpoint.prototype.contains = function(point) {
        var delta;
        delta = point.subtract(this.rectangle.center);
        delta.rotation = -this.rotation;
        return this.rectangle.contains(this.rectangle.center.add(delta));
      };

      Checkpoint.prototype.remove = function() {
        var _ref;
        if ((_ref = this.lock) != null) {
          _ref.checkpoints.remove(this);
        }
        Checkpoint.__super__.remove.call(this);
      };

      return Checkpoint;

    })(g.RShape);
    g.Checkpoint = Checkpoint;
    g.pathClasses.push(g.Checkpoint);
    StripeAnimation = (function(_super) {
      __extends(StripeAnimation, _super);

      function StripeAnimation() {
        this.onFrame = __bind(this.onFrame, this);
        this.rasterLoaded = __bind(this.rasterLoaded, this);
        return StripeAnimation.__super__.constructor.apply(this, arguments);
      }

      StripeAnimation.Shape = paper.Path.Rectangle;

      StripeAnimation.rname = 'Stripe animation';

      StripeAnimation.rdescription = "Creates a stripe animation from a set sequence of image.";

      StripeAnimation.squareByDefault = false;

      StripeAnimation.initializeParameters = function() {
        var parameters;
        parameters = StripeAnimation.__super__.constructor.initializeParameters.call(this);
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].stripeWidth = {
          type: 'slider',
          label: 'Stripe width',
          min: 1,
          max: 5,
          "default": 1
        };
        parameters['Parameters'].maskWidth = {
          type: 'slider',
          label: 'Mask width',
          min: 1,
          max: 4,
          "default": 1
        };
        parameters['Parameters'].speed = {
          type: 'slider',
          label: 'Speed',
          min: 0.01,
          max: 1.0,
          "default": 0.1
        };
        return parameters;
      };

      StripeAnimation.parameters = StripeAnimation.initializeParameters();

      StripeAnimation.prototype.initialize = function() {
        var dropZone, handleDragOver, handleFileSelect, modalBodyJ, modalContentJ;
        this.data.animate = true;
        this.setAnimated(this.data.animate);
        this.modalJ = $('#customModal');
        modalBodyJ = this.modalJ.find('.modal-body');
        modalBodyJ.empty();
        modalContentJ = $("<div id=\"stripeAnimationContent\" class=\"form-group url-group\">\n	                <label for=\"stripeAnimationModalURL\">Add your images</label>\n	                <input id=\"stripeAnimationFileInput\" type=\"file\" class=\"form-control\" name=\"files[]\" multiple/>\n	                <div id=\"stripeAnimationDropZone\">Drop your image files here.</div>\n	                <div id=\"stripeAnimationGallery\"></div>\n	            </div>");
        modalBodyJ.append(modalContentJ);
        this.modalJ.modal('show');
        if (window.File && window.FileReader && window.FileList && window.Blob) {
          console.log('File upload supported');
        } else {
          console.log('File upload not supported');
          g.romanesco_alert('File upload not supported', 'error');
        }
        handleFileSelect = (function(_this) {
          return function(evt) {
            var f, files, i, reader, _ref, _ref1;
            evt.stopPropagation();
            evt.preventDefault();
            files = ((_ref = evt.dataTransfer) != null ? _ref.files : void 0) || ((_ref1 = evt.target) != null ? _ref1.files : void 0);
            _this.nRasterToLoad = files.length;
            _this.nRasterLoaded = 0;
            _this.rasters = [];
            i = 0;
            f = void 0;
            while (f = files[i]) {
              if (!f.type.match('image.*')) {
                i++;
                continue;
              }
              reader = new FileReader;
              reader.onload = (function(theFile, stripeAnimation) {
                return function(e) {
                  var span;
                  span = document.createElement('span');
                  span.innerHTML = ['<img class="thumb" src="', e.target.result, '" title="', escape(theFile.name), '"/>'].join('');
                  $("#stripeAnimationGallery").append(span);
                  stripeAnimation.rasters.push(new Raster(e.target.result));
                  stripeAnimation.nRasterLoaded++;
                  if (stripeAnimation.nRasterLoaded === stripeAnimation.nRasterToLoad) {
                    stripeAnimation.rasterLoaded();
                  }
                };
              })(f, _this);
              reader.readAsDataURL(f);
              i++;
            }
          };
        })(this);
        $("#stripeAnimationFileInput").change(handleFileSelect);
        handleDragOver = function(evt) {
          evt.stopPropagation();
          evt.preventDefault();
          evt.dataTransfer.dropEffect = 'copy';
        };
        dropZone = document.getElementById('stripeAnimationDropZone');
        dropZone.addEventListener('dragover', handleDragOver, false);
        dropZone.addEventListener('drop', handleFileSelect, false);
      };

      StripeAnimation.prototype.rasterLoaded = function() {
        var black, blackStripeWidth, i, n, nStripes, nVisibleFrames, position, raster, size, stripeData, stripesContext, transparent, width, _i, _j, _k, _len, _len1, _ref, _ref1;
        if ((this.rasters == null) || this.rasters.length === 0) {
          return;
        }
        if (this.nRasterLoaded !== this.nRasterToLoad) {
          return;
        }
        this.minSize = new Size();
        _ref = this.rasters;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          raster = _ref[_i];
          if (this.minSize.width === 0 || raster.width < this.minSize.width) {
            this.minSize.width = raster.width;
          }
          if (this.minSize.height === 0 || raster.height < this.minSize.height) {
            this.minSize.height = raster.height;
          }
        }
        _ref1 = this.rasters;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          raster = _ref1[_j];
          raster.size = this.minSize;
        }
        size = this.rasters[0].size;
        this.result = new Raster();
        this.result.position = this.rectangle.center;
        this.result.size = size;
        this.result.name = 'stripe animation raster';
        this.result.controller = this;
        this.drawing.addChild(this.result);
        this.stripes = new Raster();
        this.stripes.size = new Size(size.width * 2, size.height);
        this.stripes.position = this.rectangle.center;
        this.stripes.name = 'stripe mask raster';
        this.stripes.controller = this;
        this.drawing.addChild(this.stripes);
        n = this.rasters.length;
        width = this.data.stripeWidth;
        black = new Color(0, 0, 0);
        transparent = new Color(0, 0, 0, 0);
        nStripes = Math.floor(size.width / width);
        for (i = _k = 0; 0 <= nStripes ? _k <= nStripes : _k >= nStripes; i = 0 <= nStripes ? ++_k : --_k) {
          stripeData = this.rasters[i % n].getImageData(new Rectangle(i * width, 0, width, size.height));
          this.result.setImageData(stripeData, new Point(i * width, 0));
        }
        stripesContext = this.stripes.canvas.getContext("2d");
        stripesContext.fillStyle = "rgb(0, 0, 0)";
        nVisibleFrames = Math.min(this.data.maskWidth, n - 1);
        blackStripeWidth = width * (n - nVisibleFrames);
        position = nVisibleFrames * width;
        while (position < this.stripes.width) {
          stripesContext.fillRect(position, 0, blackStripeWidth, size.height);
          position += width * n;
        }
      };

      StripeAnimation.prototype.createShape = function() {
        this.rasterLoaded();
      };

      StripeAnimation.prototype.onFrame = function(event) {
        if (this.stripes == null) {
          return;
        }
        this.stripes.position.x -= this.data.speed;
        if (this.stripes.bounds.center.x < this.rectangle.left) {
          this.stripes.bounds.center.x = this.rectangle.right;
        }
      };

      return StripeAnimation;

    })(g.RShape);
    g.StripeAnimation = StripeAnimation;
    g.pathClasses.push(g.StripeAnimation);
    Medusa = (function(_super) {
      __extends(Medusa, _super);

      function Medusa() {
        this.onFrame = __bind(this.onFrame, this);
        return Medusa.__super__.constructor.apply(this, arguments);
      }

      Medusa.Shape = paper.Path.Rectangle;

      Medusa.rname = 'Medusa';

      Medusa.rdescription = "Creates a bunch of aniamted Medusa.";

      Medusa.squareByDefault = true;

      Medusa.initializeParameters = function() {
        var parameters;
        parameters = Medusa.__super__.constructor.initializeParameters.call(this);
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].stripeWidth = {
          type: 'slider',
          label: 'Stripe width',
          min: 1,
          max: 5,
          "default": 1
        };
        parameters['Parameters'].maskWidth = {
          type: 'slider',
          label: 'Mask width',
          min: 1,
          max: 4,
          "default": 1
        };
        parameters['Parameters'].speed = {
          type: 'slider',
          label: 'Speed',
          min: 0.01,
          max: 1.0,
          "default": 0.1
        };
        return parameters;
      };

      Medusa.parameters = Medusa.initializeParameters();

      Medusa.prototype.initialize = function() {
        this.data.animate = true;
        this.setAnimated(this.data.animate);
      };

      Medusa.prototype.createShape = function() {
        var i, j, normal, point, position, step, tentacle, topSegment, _i, _j;
        this.data.nTentacles;
        this.data.nSegments;
        this.data.pulsePeriod;
        this.data.elasticConstant;
        this.path = this.addPath();
        topSegment = new Segment(this.rectangle.center.x, this.rectangle.top);
        topSegment.handleIn = new Point(-this.rectangle.width / 3, 0);
        topSegment.handleOut = new Point(this.rectangle.width / 3, 0);
        this.path.add(topSegment);
        this.leftSegment = new Segment(this.rectangle.left, this.rectangle.top + this.rectangle.height * 0.7);
        this.leftSegment.handleIn = new Point(0, -this.rectangle.height * 0.5);
        this.leftSegment.handleOut = new Point(0, this.rectangle.height * 0.3);
        this.path.add(this.leftSegment);
        this.rightSegment = new Segment(this.rectangle.right, this.rectangle.top + this.rectangle.height * 0.7);
        this.rightSegment.handleIn = new Point(0, -this.rectangle.height * 0.5);
        this.rightSegment.handleOut = new Point(0, this.rectangle.height * 0.3);
        this.path.add(this.rightSegment);
        position = this.leftSegment.location.offset;
        step = (this.rightSegment.location.offset - this.leftSegment.location.offset) / nTentacles;
        this.tentacles = [];
        for (i = _i = 0; 0 <= nTentacles ? _i <= nTentacles : _i >= nTentacles; i = 0 <= nTentacles ? ++_i : --_i) {
          console.log("draw tentacle");
          point = this.path.getPointAt(position);
          normal = this.path.getNormalAt(position);
          tentacle = this.addPath();
          tentacle.add(point);
          for (j = _j = 0; 0 <= nSegments ? _j <= nSegments : _j >= nSegments; j = 0 <= nSegments ? ++_j : --_j) {
            tentacle.add(point.add(normal.multiply(j)));
          }
          this.tentacles.push(tentacle);
          position += step;
        }
      };

      Medusa.prototype.onFrame = function(event) {
        var delta, direction, force, lastPoint, normal, position, segment, step, tentacle, time, _i, _j, _len, _len1, _ref, _ref1;
        direction = new Point(1, 0);
        direction.angle = this.rotation;
        normal = direction.clone();
        normal.angle += 90;
        force = null;
        time = Date.now();
        if (time > this.lastUpdate + this.data.pulsePeriod) {
          this.lastUpdate = time;
          force = normal.multiply(this.data.pulseAmplitude);
        } else {
          force = normal.multiply(-0.1 * this.data.pulseAmplitude);
        }
        this.leftSegment.point = this.leftSegment.point.add(force);
        this.rightSegment.point = this.rightSegment.point.subtract(force);
        position = this.leftSegment.location.offset;
        step = (this.rightSegment.location.offset - this.leftSegment.location.offset) / nTentacles;
        _ref = this.tentacles;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tentacle = _ref[_i];
          lastPoint = this.path.getPointAt(position);
          _ref1 = tentacle.segments;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            segment = _ref1[_j];
            delta = lastPoint.subtract(segment.point);
            segment.point.translate(delta.multiply(this.data.elasticConstant));
            lastPoint = segment.point;
          }
          position += step;
        }
      };

      return Medusa;

    })(g.RShape);
    g.Medusa = Medusa;
    g.pathClasses.push(g.Medusa);
  });

}).call(this);

//# sourceMappingURL=path.map
