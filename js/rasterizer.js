// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['utils', 'jquery', 'paper'], function(utils) {
    var CanvasTileRasterizer, InstantPaperTileRasterizer, PaperTileRasterizer, Rasterizer, TileRasterizer, g;
    g = utils.g();
    Rasterizer = (function() {
      Rasterizer.TYPE = 'default';

      Rasterizer.MAX_AREA = 1.5;

      Rasterizer.UNION_RATIO = 1.5;

      function Rasterizer() {
        g.rasterizers[this.constructor.TYPE] = this;
        this.rasterizeItems = true;
        return;
      }

      Rasterizer.prototype.quantizeBounds = function(bounds, scale) {
        var quantizedBounds;
        if (bounds == null) {
          bounds = view.bounds;
        }
        if (scale == null) {
          scale = g.scale;
        }
        quantizedBounds = {
          t: g.floorToMultiple(bounds.top, scale),
          l: g.floorToMultiple(bounds.left, scale),
          b: g.floorToMultiple(bounds.bottom, scale),
          r: g.floorToMultiple(bounds.right, scale)
        };
        return quantizedBounds;
      };

      Rasterizer.prototype.rasterize = function(items, excludeItems) {};

      Rasterizer.prototype.unload = function(limit) {};

      Rasterizer.prototype.load = function(rasters, qZoom) {};

      Rasterizer.prototype.move = function() {};

      Rasterizer.prototype.loadItem = function(item) {
        if (typeof item.draw === "function") {
          item.draw();
        }
        if (this.rasterizeItems) {
          if (typeof item.rasterize === "function") {
            item.rasterize();
          }
        }
      };

      Rasterizer.prototype.requestDraw = function() {
        return true;
      };

      Rasterizer.prototype.selectItem = function(item) {};

      Rasterizer.prototype.deselectItem = function(item) {
        if (typeof item.rasterize === "function") {
          item.rasterize();
        }
      };

      Rasterizer.prototype.rasterizeRectangle = function(rectangle) {};

      Rasterizer.prototype.addAreaToUpdate = function(area) {};

      Rasterizer.prototype.setQZoomToUpdate = function(qZoom) {};

      Rasterizer.prototype.rasterizeAreasToUpdate = function() {};

      Rasterizer.prototype.maxArea = function() {
        return view.bounds.area * this.constructor.MAX_AREA;
      };

      Rasterizer.prototype.rasterizeView = function() {};

      Rasterizer.prototype.clearRasters = function() {};

      Rasterizer.prototype.drawItems = function() {};

      Rasterizer.prototype.rasterizeAllItems = function() {
        var item, pk, _ref;
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          if (typeof item.rasterize === "function") {
            item.rasterize();
          }
        }
      };

      Rasterizer.prototype.hideOthers = function(itemsToExclude) {};

      Rasterizer.prototype.showItems = function() {};

      Rasterizer.prototype.hideRasters = function() {};

      Rasterizer.prototype.showRasters = function() {};

      Rasterizer.prototype.extractImage = function(rectangle, redraw) {
        return g.areaToImageDataUrl(rectangle);
      };

      return Rasterizer;

    })();
    g.Rasterizer = Rasterizer;
    TileRasterizer = (function(_super) {
      __extends(TileRasterizer, _super);

      TileRasterizer.TYPE = 'abstract tile';

      TileRasterizer.loadingBarJ = null;

      function TileRasterizer() {
        this.rasterizeCallback = __bind(this.rasterizeCallback, this);
        this.rasterizeImmediately = __bind(this.rasterizeImmediately, this);
        TileRasterizer.__super__.constructor.call(this);
        this.itemsToExclude = [];
        this.areaToRasterize = null;
        this.areasToUpdate = [];
        this.rasters = {};
        this.rasterizeItems = true;
        this.rasterizationDisabled = false;
        this.autoRasterization = 'deferred';
        this.rasterizationDelay = 800;
        this.renderInView = false;
        this.itemsAreDrawn = false;
        this.itemsAreVisible = false;
        this.move();
        return;
      }

      TileRasterizer.prototype.loadItem = function(item) {
        var _ref;
        if (((_ref = item.data) != null ? _ref.animate : void 0) || g.selectedToolNeedsDrawings()) {
          if (typeof item.draw === "function") {
            item.draw();
          }
        } else {
          this.itemsAreDrawn = false;
        }
        if (this.rasterizeItems) {
          if (typeof item.rasterize === "function") {
            item.rasterize();
          }
        }
      };

      TileRasterizer.prototype.startLoading = function() {
        this.startLoadingTime = view._time;
        g.TileRasterizer.loadingBarJ.css({
          width: 0
        });
        g.TileRasterizer.loadingBarJ.show();
        g.deferredExecution(this.rasterizeCallback, 'rasterize', this.rasterizationDelay);
      };

      TileRasterizer.prototype.stopLoading = function(cancelTimeout) {
        if (cancelTimeout == null) {
          cancelTimeout = true;
        }
        this.startLoadingTime = null;
        g.TileRasterizer.loadingBarJ.hide();
        if (cancelTimeout) {
          clearTimeout(g.updateTimeout['rasterize']);
        }
      };

      TileRasterizer.prototype.rasterizeImmediately = function() {
        this.stopLoading();
        this.rasterizeCallback();
      };

      TileRasterizer.prototype.updateLoadingBar = function(time) {
        var duration, totalWidth;
        if (this.startLoadingTime == null) {
          return;
        }
        duration = 1000 * (time - this.startLoadingTime) / this.rasterizationDelay;
        totalWidth = 241;
        g.TileRasterizer.loadingBarJ.css({
          width: duration * totalWidth
        });
        if (duration >= 1) {
          this.stopLoading(false);
        }
      };

      TileRasterizer.prototype.drawItemsAndHideRasters = function() {
        this.drawItems(true);
        this.hideRasters();
      };

      TileRasterizer.prototype.selectItem = function(item) {
        this.drawItems();
        this.rasterize(item, true);
        switch (this.autoRasterization) {
          case 'disabled':
            this.drawItemsAndHideRasters();
            item.group.visible = true;
            break;
          case 'deferred':
            this.drawItemsAndHideRasters();
            item.group.visible = true;
            this.stopLoading();
            break;
          case 'immediate':
            g.callNextFrame(this.rasterizeCallback, 'rasterize');
        }
      };

      TileRasterizer.prototype.deselectItem = function(item) {
        if (this.rasterizeItems) {
          if (typeof item.rasterize === "function") {
            item.rasterize();
          }
        }
        this.rasterize(item);
        switch (this.autoRasterization) {
          case 'deferred':
            this.startLoading();
            break;
          case 'immediate':
            g.callNextFrame(this.rasterizeCallback, 'rasterize');
        }
      };

      TileRasterizer.prototype.rasterLoaded = function(raster) {
        var allRastersAreReady, rasterColumn, x, y, _ref;
        raster.context.clearRect(0, 0, g.scale, g.scale);
        raster.context.drawImage(raster.image, 0, 0);
        raster.ready = true;
        raster.loaded = true;
        allRastersAreReady = true;
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            allRastersAreReady &= raster.ready;
          }
        }
        if (allRastersAreReady) {
          this.rasterizeAreasToUpdate();
        }
      };

      TileRasterizer.prototype.createRaster = function(x, y, zoom, raster) {
        var _base;
        raster.zoom = zoom;
        raster.ready = true;
        raster.loaded = false;
        if ((_base = this.rasters)[x] == null) {
          _base[x] = {};
        }
        this.rasters[x][y] = raster;
      };

      TileRasterizer.prototype.getRasterBounds = function(x, y) {
        var size;
        size = this.rasters[x][y].zoom * g.scale;
        return new Rectangle(x, y, size, size);
      };

      TileRasterizer.prototype.removeRaster = function(raster, x, y) {
        delete this.rasters[x][y];
        if (g.isEmpty(this.rasters[x])) {
          delete this.rasters[x];
        }
      };

      TileRasterizer.prototype.unload = function(limit) {
        var qZoom, raster, rasterColumn, rectangle, x, y, _ref;
        qZoom = g.quantizeZoom(1.0 / view.zoom);
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          x = Number(x);
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            y = Number(y);
            rectangle = this.getRasterBounds(x, y);
            if (!limit.intersects(rectangle) || this.rasters[x][y].zoom !== qZoom) {
              this.removeRaster(raster, x, y);
            }
          }
        }
      };

      TileRasterizer.prototype.loadImageForRaster = function(raster, url) {};

      TileRasterizer.prototype.load = function(rasters, qZoom) {
        var r, raster, url, x, y, _i, _len, _ref;
        this.move();
        for (_i = 0, _len = rasters.length; _i < _len; _i++) {
          r = rasters[_i];
          x = r.position.x * g.scale;
          y = r.position.y * g.scale;
          raster = (_ref = this.rasters[x]) != null ? _ref[y] : void 0;
          if (raster && !raster.loaded) {
            raster.ready = false;
            url = g.romanescoURL + r.url + '?' + Math.random();
            this.loadImageForRaster(raster, url);
          }
        }
      };

      TileRasterizer.prototype.createRasters = function(rectangle) {
        var qBounds, qZoom, scale, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
        qZoom = g.quantizeZoom(1.0 / view.zoom);
        scale = g.scale * qZoom;
        qBounds = this.quantizeBounds(rectangle, scale);
        for (x = _i = _ref = qBounds.l, _ref1 = qBounds.r; scale > 0 ? _i <= _ref1 : _i >= _ref1; x = _i += scale) {
          for (y = _j = _ref2 = qBounds.t, _ref3 = qBounds.b; scale > 0 ? _j <= _ref3 : _j >= _ref3; y = _j += scale) {
            this.createRaster(x, y, qZoom);
          }
        }
      };

      TileRasterizer.prototype.move = function() {
        this.createRasters(view.bounds);
      };

      TileRasterizer.prototype.splitAreaToRasterize = function() {
        var area, areaToRasterizeInteger, areas, maxSize;
        maxSize = view.size.multiply(2);
        areaToRasterizeInteger = g.expandRectangleToInteger(this.areaToRasterize);
        area = g.expandRectangleToInteger(new Rectangle(this.areaToRasterize.topLeft, Size.min(maxSize, this.areaToRasterize.size)));
        areas = [area.clone()];
        while (area.right < this.areaToRasterize.right || area.bottom < this.areaToRasterize.bottom) {
          if (area.right < this.areaToRasterize.right) {
            area.x += maxSize.width;
          } else {
            area.x = areaToRasterizeInteger.left;
            area.y += maxSize.height;
          }
          areas.push(area.intersect(areaToRasterizeInteger));
        }
        return areas;
      };

      TileRasterizer.prototype.rasterizeCanvasInRaster = function(x, y, canvas, rectangle, qZoom, clearRasters, sourceRectangle) {
        var context, destinationRectangle, intersection, rasterRectangle, _ref;
        if (clearRasters == null) {
          clearRasters = false;
        }
        if (sourceRectangle == null) {
          sourceRectangle = null;
        }
        if (((_ref = this.rasters[x]) != null ? _ref[y] : void 0) == null) {
          return;
        }
        rasterRectangle = this.getRasterBounds(x, y);
        intersection = rectangle.intersect(rasterRectangle);
        destinationRectangle = new Rectangle(intersection.topLeft.subtract(rasterRectangle.topLeft).divide(qZoom), intersection.size.divide(qZoom));
        context = this.rasters[x][y].context;
        if (clearRasters) {
          context.clearRect(destinationRectangle.x, destinationRectangle.y, destinationRectangle.width, destinationRectangle.height);
        }
        if (canvas != null) {
          if (sourceRectangle != null) {
            sourceRectangle = new Rectangle(intersection.topLeft.subtract(sourceRectangle.topLeft), intersection.size);
          } else {
            sourceRectangle = new Rectangle(intersection.topLeft.subtract(rectangle.topLeft).divide(qZoom), intersection.size.divide(qZoom));
          }
          context.drawImage(canvas, sourceRectangle.x, sourceRectangle.y, sourceRectangle.width, sourceRectangle.height, destinationRectangle.x, destinationRectangle.y, destinationRectangle.width, destinationRectangle.height);
        }
      };

      TileRasterizer.prototype.rasterizeCanvas = function(canvas, rectangle, clearRasters, sourceRectangle) {
        var qBounds, qZoom, scale, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
        if (clearRasters == null) {
          clearRasters = false;
        }
        if (sourceRectangle == null) {
          sourceRectangle = null;
        }
        console.log("rasterize: " + rectangle.width + ", " + rectangle.height);
        qZoom = g.quantizeZoom(1.0 / view.zoom);
        scale = g.scale * qZoom;
        qBounds = this.quantizeBounds(rectangle, scale);
        for (x = _i = _ref = qBounds.l, _ref1 = qBounds.r; scale > 0 ? _i <= _ref1 : _i >= _ref1; x = _i += scale) {
          for (y = _j = _ref2 = qBounds.t, _ref3 = qBounds.b; scale > 0 ? _j <= _ref3 : _j >= _ref3; y = _j += scale) {
            this.rasterizeCanvasInRaster(x, y, canvas, rectangle, qZoom, clearRasters, sourceRectangle);
          }
        }
      };

      TileRasterizer.prototype.clearAreaInRasters = function(rectangle) {
        this.rasterizeCanvas(null, rectangle, true);
      };

      TileRasterizer.prototype.rasterizeArea = function(area) {
        view.viewSize = area.size.multiply(view.zoom);
        view.center = area.center;
        view.update();
        this.rasterizeCanvas(g.canvas, area, true);
      };

      TileRasterizer.prototype.rasterizeAreas = function(areas) {
        var area, viewPosition, viewSize, viewZoom, _i, _len;
        viewZoom = view.zoom;
        viewSize = view.viewSize;
        viewPosition = view.center;
        view.zoom = 1.0 / g.quantizeZoom(1.0 / view.zoom);
        for (_i = 0, _len = areas.length; _i < _len; _i++) {
          area = areas[_i];
          this.rasterizeArea(area);
        }
        view.zoom = viewZoom;
        view.viewSize = viewSize;
        view.center = viewPosition;
      };

      TileRasterizer.prototype.prepareView = function() {
        var item, pk, _i, _len, _ref, _ref1, _ref2, _ref3;
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          item.group.visible = true;
        }
        _ref1 = this.itemsToExclude;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          if ((_ref2 = item.group) != null) {
            _ref2.visible = false;
          }
        }
        g.grid.visible = false;
        g.selectionLayer.visible = false;
        g.carLayer.visible = false;
        this.viewOnFrame = view.onFrame;
        view.onFrame = null;
        if ((_ref3 = this.rasterLayer) != null) {
          _ref3.visible = false;
        }
      };

      TileRasterizer.prototype.restoreView = function() {
        var _ref;
        if ((_ref = this.rasterLayer) != null) {
          _ref.visible = true;
        }
        view.onFrame = this.viewOnFrame;
        g.carLayer.visible = true;
        g.selectionLayer.visible = true;
        g.grid.visible = true;
      };

      TileRasterizer.prototype.rasterizeCallback = function(step) {
        var area, areas, item, pk, sortedItems, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4;
        if (!this.areaToRasterize) {
          return;
        }
        console.log("rasterize");
        g.logElapsedTime();
        g.startTimer();
        if (this.autoRasterization === 'deferred' || this.autoRasterization === 'disabled') {
          this.showRasters();
        }
        areas = this.splitAreaToRasterize();
        if (this.renderInView) {
          this.prepareView();
          this.rasterizeAreas(areas);
          this.restoreView();
        } else {
          sortedItems = g.getSortedItems();
          for (_i = 0, _len = areas.length; _i < _len; _i++) {
            area = areas[_i];
            this.clearAreaInRasters(area);
            for (_j = 0, _len1 = sortedItems.length; _j < _len1; _j++) {
              item = sortedItems[_j];
              if (((_ref = item.raster) != null ? _ref.bounds.intersects(area) : void 0) && __indexOf.call(this.itemsToExclude, item) < 0) {
                this.rasterizeCanvas(item.raster.canvas, item.raster.bounds.intersect(area), false, item.raster.bounds);
              }
            }
          }
        }
        _ref1 = g.items;
        for (pk in _ref1) {
          item = _ref1[pk];
          if (item === g.currentPaths[g.me] || (item.selectionRectangle != null)) {
            continue;
          }
          if ((_ref2 = item.group) != null) {
            _ref2.visible = false;
          }
        }
        _ref3 = this.itemsToExclude;
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          item = _ref3[_k];
          if ((_ref4 = item.group) != null) {
            _ref4.visible = true;
          }
          if (typeof item.showChildren === "function") {
            item.showChildren();
          }
        }
        this.itemsToExclude = [];
        this.areaToRasterize = null;
        this.itemsAreVisible = false;
        this.stopLoading();
        g.stopTimer('Time to rasterize path: ');
        g.logElapsedTime();
      };

      TileRasterizer.prototype.rasterize = function(items, excludeItems) {
        var item, _i, _len;
        if (this.rasterizationDisabled) {
          return;
        }
        console.log("ask rasterize" + (excludeItems ? " excluding items." : ""));
        g.logElapsedTime();
        if (!g.isArray(items)) {
          items = [items];
        }
        if (!excludeItems) {
          this.itemsToExclude = [];
        }
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (this.areaToRasterize == null) {
            this.areaToRasterize = item.getDrawingBounds();
          }
          this.areaToRasterize = this.areaToRasterize.unite(item.getDrawingBounds());
          if (excludeItems) {
            g.pushIfAbsent(this.itemsToExclude, item);
          }
        }
      };

      TileRasterizer.prototype.rasterizeRectangle = function(rectangle) {
        this.drawItems();
        if (this.areaToRasterize == null) {
          this.areaToRasterize = rectangle;
        } else {
          this.areaToRasterize = this.areaToRasterize.unite(rectangle);
        }
        g.callNextFrame(this.rasterizeCallback, 'rasterize');
      };

      TileRasterizer.prototype.addAreaToUpdate = function(area) {
        this.areasToUpdate.push(area);
      };

      TileRasterizer.prototype.setQZoomToUpdate = function(qZoom) {
        this.areasToUpdateQZoom = qZoom;
      };

      TileRasterizer.prototype.rasterizeAreasToUpdate = function() {
        var area, previousAreaToRasterize, previousItemsToExclude, previousZoom, _i, _len, _ref;
        if (this.areasToUpdate.length === 0) {
          return;
        }
        this.drawItems(true);
        previousItemsToExclude = this.itemsToExclude;
        previousAreaToRasterize = this.areaToRasterize;
        previousZoom = view.zoom;
        view.zoom = 1.0 / this.areasToUpdateQZoom;
        this.itemsToExclude = [];
        _ref = this.areasToUpdate;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          area = _ref[_i];
          this.areaToRasterize = area;
          this.rasterizeCallback();
        }
        this.areasToUpdate = [];
        this.itemsToExclude = previousItemsToExclude;
        this.areaToRasterize = previousAreaToRasterize;
        view.zoom = previousZoom;
      };

      TileRasterizer.prototype.clearRasters = function() {
        var raster, rasterColumn, x, y, _ref;
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            raster.context.clearRect(0, 0, g.scale, g.scale);
          }
        }
      };

      TileRasterizer.prototype.drawItems = function(showItems) {
        var item, pk, _ref;
        if (showItems == null) {
          showItems = false;
        }
        if (showItems) {
          this.showItems();
        }
        if (this.itemsAreDrawn) {
          return;
        }
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          if (item.drawing == null) {
            if (typeof item.draw === "function") {
              item.draw();
            }
          }
          if (this.rasterizeItems) {
            if (typeof item.rasterize === "function") {
              item.rasterize();
            }
          }
        }
        this.itemsAreDrawn = true;
      };

      TileRasterizer.prototype.showItems = function() {
        var item, pk, _ref;
        if (this.itemsAreVisible) {
          return;
        }
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          item.group.visible = true;
        }
        this.itemsAreVisible = true;
      };

      TileRasterizer.prototype.disableRasterization = function() {
        this.rasterizationDisabled = true;
        this.clearRasters();
        this.drawItems(true);
      };

      TileRasterizer.prototype.enableRasterization = function() {
        this.rasterizationDisabled = false;
        this.rasterizeView();
      };

      TileRasterizer.prototype.rasterizeView = function() {
        this.rasterizeRectangle(view.bounds);
      };

      TileRasterizer.prototype.hideRasters = function() {};

      TileRasterizer.prototype.showRasters = function() {};

      TileRasterizer.prototype.hideOthers = function(itemToExclude) {
        var item, pk, _ref;
        console.log(itemToExclude.pk);
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          if (item !== itemToExclude) {
            item.group.visible = false;
          }
        }
      };

      TileRasterizer.prototype.extractImage = function(rectangle, redraw) {
        var dataURL, disableDrawing, item, pk, rasterizeItems, _ref;
        if (redraw) {
          rasterizeItems = this.rasterizeItems;
          this.rasterizeItems = false;
          disableDrawing = this.disableDrawing;
          this.disableDrawing = false;
          this.drawItemsAndHideRasters();
          dataURL = g.areaToImageDataUrl(rectangle);
          if (rasterizeItems) {
            this.rasterizeItems = true;
            _ref = g.items;
            for (pk in _ref) {
              item = _ref[pk];
              if (typeof item.rasterize === "function") {
                item.rasterize();
              }
            }
          }
          if (disableDrawing) {
            this.disableDrawing = true;
          }
          this.showRasters();
          this.rasterizeImmediately();
          return dataURL;
        } else {
          return g.areaToImageDataUrl(rectangle);
        }
      };

      return TileRasterizer;

    })(g.Rasterizer);
    g.TileRasterizer = TileRasterizer;
    PaperTileRasterizer = (function(_super) {
      __extends(PaperTileRasterizer, _super);

      PaperTileRasterizer.TYPE = 'paper tile';

      function PaperTileRasterizer() {
        this.rasterLayer = new Layer();
        this.rasterLayer.name = 'raster layer';
        this.rasterLayer.moveBelow(g.mainLayer);
        g.mainLayer.activate();
        PaperTileRasterizer.__super__.constructor.call(this);
        return;
      }

      PaperTileRasterizer.prototype.createRaster = function(x, y, zoom) {
        var raster, _ref;
        if (((_ref = this.rasters[x]) != null ? _ref[y] : void 0) != null) {
          return;
        }
        raster = new Raster();
        raster.name = 'raster: ' + x + ', ' + y;
        console.log(raster.name);
        raster.position.x = x + 0.5 * g.scale * zoom;
        raster.position.y = y + 0.5 * g.scale * zoom;
        raster.width = g.scale;
        raster.height = g.scale;
        raster.scale(zoom);
        raster.context = raster.canvas.getContext('2d');
        this.rasterLayer.addChild(raster);
        raster.onLoad = (function(_this) {
          return function() {
            raster.context = raster.canvas.getContext('2d');
            _this.rasterLoaded(raster);
          };
        })(this);
        PaperTileRasterizer.__super__.createRaster.call(this, x, y, zoom, raster);
      };

      PaperTileRasterizer.prototype.removeRaster = function(raster, x, y) {
        raster.remove();
        PaperTileRasterizer.__super__.removeRaster.call(this, raster, x, y);
      };

      PaperTileRasterizer.prototype.loadImageForRaster = function(raster, url) {
        raster.source = url;
      };

      PaperTileRasterizer.prototype.hideRasters = function() {
        var raster, rasterColumn, x, y, _ref;
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            raster.visible = false;
          }
        }
      };

      PaperTileRasterizer.prototype.showRasters = function() {
        var raster, rasterColumn, x, y, _ref;
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            raster.visible = true;
          }
        }
      };

      return PaperTileRasterizer;

    })(g.TileRasterizer);
    g.PaperTileRasterizer = PaperTileRasterizer;
    InstantPaperTileRasterizer = (function(_super) {
      __extends(InstantPaperTileRasterizer, _super);

      InstantPaperTileRasterizer.TYPE = 'light';

      function InstantPaperTileRasterizer() {
        InstantPaperTileRasterizer.__super__.constructor.call(this);
        this.disableDrawing = true;
        this.updateDrawingAfterDelay = true;
        this.itemsToDraw = {};
        return;
      }

      InstantPaperTileRasterizer.prototype.drawItemsAndHideRasters = function() {};

      InstantPaperTileRasterizer.prototype.requestDraw = function(item, simplified, redrawing) {
        var delay, time;
        if (this.disableDrawing) {
          if (this.updateDrawingAfterDelay) {
            time = Date.now();
            delay = 500;
            if ((this.itemsToDraw[item.pk] == null) || time - this.itemsToDraw[item.pk] < delay) {
              this.itemsToDraw[item.pk] = time;
              g.deferredExecution(item.draw, 'item.draw:' + item.pk, delay, [simplified, redrawing], item);
            } else {
              delete this.itemsToDraw[item.pk];
              return true;
            }
          }
        }
        return !this.disableDrawing;
      };

      InstantPaperTileRasterizer.prototype.selectItem = function(item) {
        if (!this.rasterizeItems) {
          item.removeDrawing();
        }
        InstantPaperTileRasterizer.__super__.selectItem.call(this, item);
      };

      InstantPaperTileRasterizer.prototype.deselectItem = function(item) {
        InstantPaperTileRasterizer.__super__.deselectItem.call(this, item);
        if (!this.rasterizeItems) {
          item.replaceDrawing();
        }
      };

      InstantPaperTileRasterizer.prototype.rasterizeCallback = function(step) {
        var item, pk, _ref;
        this.disableDrawing = false;
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          if ((item.drawn != null) && !item.drawn && item.getDrawingBounds().intersects(this.areaToRasterize)) {
            if (typeof item.draw === "function") {
              item.draw();
            }
            if (this.rasterizeItems) {
              if (typeof item.rasterize === "function") {
                item.rasterize();
              }
            }
          }
        }
        this.disableDrawing = true;
        InstantPaperTileRasterizer.__super__.rasterizeCallback.call(this, step);
      };

      InstantPaperTileRasterizer.prototype.rasterizeAreasToUpdate = function() {
        this.disableDrawing = false;
        InstantPaperTileRasterizer.__super__.rasterizeAreasToUpdate.call(this);
        this.disableDrawing = true;
      };

      return InstantPaperTileRasterizer;

    })(g.PaperTileRasterizer);
    g.InstantPaperTileRasterizer = InstantPaperTileRasterizer;
    CanvasTileRasterizer = (function(_super) {
      __extends(CanvasTileRasterizer, _super);

      CanvasTileRasterizer.TYPE = 'canvas tile';

      function CanvasTileRasterizer() {
        CanvasTileRasterizer.__super__.constructor.call(this);
        return;
      }

      CanvasTileRasterizer.prototype.createRaster = function(x, y, zoom) {
        var raster, _ref;
        raster = (_ref = this.rasters[x]) != null ? _ref[y] : void 0;
        if (raster != null) {
          return;
        }
        raster = {};
        raster.canvasJ = $('<canvas hidpi="off" width="' + g.scale + '" height="' + g.scale + '">');
        raster.canvas = raster.canvasJ[0];
        raster.context = raster.canvas.getContext('2d');
        raster.image = new Image();
        raster.image.onload = (function(_this) {
          return function() {
            _this.rasterLoaded(raster);
          };
        })(this);
        $("#rasters").append(raster.canvasJ);
        CanvasTileRasterizer.__super__.createRaster.call(this, x, y, zoom, raster);
      };

      CanvasTileRasterizer.prototype.removeRaster = function(raster, x, y) {
        raster.canvasJ.remove();
        CanvasTileRasterizer.__super__.removeRaster.call(this, raster, x, y);
      };

      CanvasTileRasterizer.prototype.loadImageForRaster = function(raster, url) {
        raster.image.src = url;
      };

      CanvasTileRasterizer.prototype.move = function() {
        var css, raster, rasterColumn, scale, viewPos, x, y, _ref;
        CanvasTileRasterizer.__super__.move.call(this);
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          x = Number(x);
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            y = Number(y);
            viewPos = view.projectToView(new Point(x, y));
            if (view.zoom === 1) {
              raster.canvasJ.css({
                'left': viewPos.x,
                'top': viewPos.y,
                'transform': 'none'
              });
            } else {
              scale = view.zoom * raster.zoom;
              css = 'translate(' + viewPos.x + 'px,' + viewPos.y + 'px)';
              css += ' scale(' + scale + ')';
              raster.canvasJ.css({
                'transform': css,
                'top': 0,
                'left': 0,
                'transform-origin': '0 0'
              });
            }
          }
        }
      };

      CanvasTileRasterizer.prototype.hideRasters = function() {
        var raster, rasterColumn, x, y, _ref;
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            raster.canvasJ.hide();
          }
        }
      };

      CanvasTileRasterizer.prototype.showRasters = function() {
        var raster, rasterColumn, x, y, _ref;
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            raster.canvasJ.show();
          }
        }
      };

      return CanvasTileRasterizer;

    })(g.TileRasterizer);
    g.CanvasTileRasterizer = CanvasTileRasterizer;
    g.initializeRasterizers = function() {
      g.rasterizers = {};
      new g.Rasterizer();
      new g.CanvasTileRasterizer();
      new g.InstantPaperTileRasterizer();
      g.rasterizer = new g.PaperTileRasterizer();
    };
    g.addRasterizerParameters = function() {
      var divJ, name, parameter, parameters, rasterizer, renderingModes, type, _ref;
      renderingModes = [];
      _ref = g.rasterizers;
      for (type in _ref) {
        rasterizer = _ref[type];
        renderingModes.push(type);
      }
      g.rasterizerFolder = new g.Folder('Rasterizer', true, g.controllerManager.folders['General']);
      divJ = $('<div>');
      divJ.addClass('loadingBar');
      $(g.rasterizerFolder.datFolder.__ul).find('li.title').append(divJ);
      g.TileRasterizer.loadingBarJ = divJ;
      parameters = {
        renderingMode: {
          "default": g.rasterizer.constructor.TYPE,
          values: renderingModes,
          label: 'Render mode',
          onFinishChange: g.setRasterizerType
        },
        rasterizeItems: {
          "default": true,
          label: 'Rasterize items',
          onFinishChange: function(value) {
            var controller, _i, _len, _ref1;
            g.rasterizer.rasterizeItems = value;
            if (!value) {
              g.rasterizer.renderInView = true;
            }
            _ref1 = g.rasterizerFolder.datFolder.__controllers;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              controller = _ref1[_i];
              if (controller.property === 'renderInView') {
                if (value) {
                  $(controller.__li).show();
                } else {
                  $(controller.__li).hide();
                }
              }
            }
          }
        },
        renderInView: {
          "default": false,
          label: 'Render in view',
          onFinishChange: function(value) {
            g.rasterizer.renderInView = value;
          }
        },
        autoRasterization: {
          "default": 'deferred',
          values: ['immediate', 'deferred', 'disabled'],
          label: 'Auto rasterization',
          onFinishChange: function(value) {
            g.rasterizer.autoRasterization = value;
          }
        },
        rasterizationDelay: {
          "default": 800,
          min: 0,
          max: 10000,
          lable: 'Delay',
          onFinishChange: function(value) {
            g.rasterizer.rasterizationDelay = value;
          }
        },
        rasterizeImmediately: {
          "default": function() {
            g.rasterizer.rasterizeImmediately();
          },
          label: 'Rasterize'
        }
      };
      for (name in parameters) {
        parameter = parameters[name];
        g.controllerManager.createController(name, parameter, g.rasterizerFolder);
      }
    };
    g.setRasterizerType = function(type) {
      var controller, onFinishChange, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      if (type === g.Rasterizer.TYPE) {
        _ref = g.rasterizerFolder.datFolder.__controllers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          controller = _ref[_i];
          if ((_ref1 = controller.property) === 'renderInView' || _ref1 === 'autoRasterization' || _ref1 === 'rasterizationDelay' || _ref1 === 'rasterizeImmediately') {
            $(controller.__li).hide();
          }
        }
      } else {
        _ref2 = g.rasterizerFolder.datFolder.__controllers;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          controller = _ref2[_j];
          $(controller.__li).show();
        }
      }
      g.unload();
      g.rasterizer = g.rasterizers[type];
      _ref3 = g.rasterizerFolder.datFolder.__controllers;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        controller = _ref3[_k];
        if (g.rasterizer[controller.property] != null) {
          onFinishChange = controller.__onFinishChange;
          controller.__onFinishChange = function() {};
          controller.setValue(g.rasterizer[controller.property]);
          controller.__onFinishChange = onFinishChange;
        }
      }
      g.load();
    };
    g.hideCanvas = function() {
      g.canvasJ.css({
        opacity: 0
      });
    };
    g.showCanvas = function() {
      g.canvasJ.css({
        opacity: 1
      });
    };
    g.hideRasters = function() {
      g.rasterizer.hideRasters();
    };
    g.showRasters = function() {
      g.rasterizer.showRasters();
    };
  });

}).call(this);

//# sourceMappingURL=rasterizer.map
