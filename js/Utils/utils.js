// Generated by CoffeeScript 1.7.1
(function() {
  define(['underscore', 'jquery', 'paper'], function(_) {
    var Utils, sqrtTwoPi, __nativeSI__, __nativeST__;
    paper.install(window.P);
    Utils = {};
    R.templatesJ = $("#templates");
    if (document.all && !window.setTimeout.isPolyfill) {
      __nativeST__ = window.setTimeout;
      window.setTimeout = function(vCallback, nDelay) {
        var aArgs;
        aArgs = Array.prototype.slice.call(arguments, 2);
        return __nativeST__((vCallback instanceof Function ? function() {
          return vCallback.apply(null, aArgs);
        } : vCallback), nDelay);
      };
      window.setTimeout.isPolyfill = true;
    }
    if (document.all && !window.setInterval.isPolyfill) {
      __nativeSI__ = window.setInterval;
      window.setInterval = function(vCallback, nDelay) {
        var aArgs;
        aArgs = Array.prototype.slice.call(arguments, 2);
        return __nativeSI__((vCallback instanceof Function ? function() {
          return vCallback.apply(null, aArgs);
        } : vCallback), nDelay);
      };
    }
    window.setInterval.isPolyfill = true;
    R.specialKeys = {
      8: 'backspace',
      9: 'tab',
      13: 'enter',
      16: 'shift',
      17: 'control',
      18: 'option',
      19: 'pause',
      20: 'caps-lock',
      27: 'escape',
      32: 'space',
      35: 'end',
      36: 'home',
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down',
      46: 'delete',
      91: 'command',
      93: 'command',
      224: 'command'
    };
    Utils.sign = function(x) {
      if (typeof x === "number") {
        if (x) {
          if (x < 0) {
            return -1;
          } else {
            return 1;
          }
        } else {
          if (x === x) {
            return 0;
          } else {
            return NaN;
          }
        }
      } else {
        return NaN;
      }
    };
    Utils.clamp = function(min, value, max) {
      return Math.min(Math.max(value, min), max);
    };
    Utils.random = function(min, max) {
      return min + Math.random() * (max - min);
    };
    Utils.Array = {};
    Utils.Array.remove = function(array, itemToRemove) {
      var i;
      if (!Array.prototype.isPrototypeOf(array)) {
        return;
      }
      i = array.indexOf(itemToRemove);
      if (i >= 0) {
        array.splice(i, 1);
      }
    };
    Utils.Array.random = function(array) {
      return array[Math.floor(Math.random() * array.length)];
    };
    Utils.Array.max = function(array) {
      var item, max, _i, _len;
      max = array[0];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (item > max) {
          max = item;
        }
      }
      return max;
    };
    Utils.Array.min = function(array) {
      var item, min, _i, _len;
      min = array[0];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (item < min) {
          min = item;
        }
      }
      return min;
    };
    Utils.Array.maxc = function(array, biggerThan) {
      var item, max, _i, _len;
      max = array[0];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (biggerThan(item, max)) {
          max = item;
        }
      }
      return max;
    };
    Utils.Array.minc = function(array, smallerThan) {
      var item, min, _i, _len;
      min = array[0];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (smallerThan(item, min)) {
          min = item;
        }
      }
      return min;
    };
    Utils.Array.isArray = function(array) {
      return array.constructor === Array;
    };
    Utils.Array.pushIfAbsent = function(array, item) {
      if (array.indexOf(item) < 0) {
        array.push(item);
      }
    };
    Utils.deferredExecutionCallbackWrapper = function(callback, id, args, oThis) {
      console.log("deferredExecutionCallbackWrapper: " + id);
      delete R.updateTimeout[id];
      if (args == null) {
        if (typeof callback === "function") {
          callback();
        }
      } else {
        if (callback != null) {
          callback.apply(oThis, args);
        }
      }
    };
    Utils.deferredExecution = function(callback, id, n, args, oThis) {
      if (n == null) {
        n = 500;
      }
      if (id == null) {
        return;
      }
      if (R.updateTimeout[id] != null) {
        clearTimeout(R.updateTimeout[id]);
      }
      console.log("deferred execution: " + id + ', ' + R.updateTimeout[id]);
      R.updateTimeout[id] = setTimeout(Utils.deferredExecutionCallbackWrapper, n, callback, id, args, oThis);
    };
    Utils.callNextFrame = function(callback, id, args) {
      var callbackWrapper, _base;
      if (id == null) {
        id = callback;
      }
      callbackWrapper = function() {
        delete R.requestedCallbacks[id];
        if (args == null) {
          callback();
        } else {
          callback.apply(window, args);
        }
      };
      if ((_base = R.requestedCallbacks)[id] == null) {
        _base[id] = window.requestAnimationFrame(callbackWrapper);
      }
    };
    Utils.cancelCallNextFrame = function(idToCancel) {
      window.cancelAnimationFrame(R.requestedCallbacks[idToCancel]);
      delete R.requestedCallbacks[idToCancel];
    };
    sqrtTwoPi = Math.sqrt(2 * Math.PI);
    Utils.gaussian = function(mean, sigma, x) {
      var expf;
      expf = -((x - mean) * (x - mean) / (2 * sigma * sigma));
      return (1.0 / (sigma * sqrtTwoPi)) * Math.exp(expf);
    };
    Utils.isEmpty = function(map) {
      var key, value;
      for (key in map) {
        value = map[key];
        if (map.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    };
    Utils.linearInterpolation = function(v1, v2, f) {
      return v1 * (1 - f) + v2 * f;
    };
    Utils.floorToMultiple = function(x, m) {
      return Math.floor(x / m) * m;
    };
    Utils.ceilToMultiple = function(x, m) {
      return Math.ceil(x / m) * m;
    };
    Utils.roundToMultiple = function(x, m) {
      return Math.round(x / m) * m;
    };
    Utils.floorPointToMultiple = function(point, m) {
      return new P.Point(Utils.floorToMultiple(point.x, m), Utils.floorToMultiple(point.y, m));
    };
    Utils.ceilPointToMultiple = function(point, m) {
      return new P.Point(Utils.ceilToMultiple(point.x, m), Utils.ceilToMultiple(point.y, m));
    };
    Utils.roundPointToMultiple = function(point, m) {
      return new P.Point(Utils.roundToMultiple(point.x, m), Utils.roundToMultiple(point.y, m));
    };
    Utils.Rectangle = {};
    Utils.Rectangle.updatePathRectangle = function(path, rectangle) {
      path.segments[0].point = rectangle.bottomLeft;
      path.segments[1].point = rectangle.topLeft;
      path.segments[2].point = rectangle.topRight;
      path.segments[3].point = rectangle.bottomRight;
    };
    Utils.Rectangle.getRotatedBounds = function(rectangle, rotation) {
      var bottomLeft, bottomRight, bounds, topLeft, topRight;
      if (rotation == null) {
        rotation = 0;
      }
      topLeft = rectangle.topLeft.subtract(rectangle.center);
      topLeft.angle += rotation;
      bottomRight = rectangle.bottomRight.subtract(rectangle.center);
      bottomRight.angle += rotation;
      bottomLeft = rectangle.bottomLeft.subtract(rectangle.center);
      bottomLeft.angle += rotation;
      topRight = rectangle.topRight.subtract(rectangle.center);
      topRight.angle += rotation;
      bounds = new P.Rectangle(rectangle.center.add(topLeft), rectangle.center.add(bottomRight));
      bounds = bounds.include(rectangle.center.add(bottomLeft));
      bounds = bounds.include(rectangle.center.add(topRight));
      return bounds;
    };
    Utils.Rectangle.shrinkRectangleToInteger = function(rectangle) {
      return new P.Rectangle(rectangle.topLeft.ceil(), rectangle.bottomRight.floor());
    };
    Utils.Rectangle.expandRectangleToInteger = function(rectangle) {
      return new P.Rectangle(rectangle.topLeft.floor(), rectangle.bottomRight.ceil());
    };
    Utils.Rectangle.expandRectangleToMultiple = function(rectangle, multiple) {
      return new P.Rectangle(Utils.floorPointToMultiple(rectangle.topLeft, multiple), Utils.ceilPointToMultiple(rectangle.bottomRight, multiple));
    };
    Utils.Rectangle.roundRectangle = function(rectangle) {
      return new P.Rectangle(rectangle.topLeft.round(), rectangle.bottomRight.round());
    };
    P.Point.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y
      };
    };
    P.Point.prototype.exportJSON = function() {
      return JSON.stringify(this.toJSON());
    };
    P.Rectangle.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    };
    P.Rectangle.prototype.exportJSON = function() {
      return JSON.stringify(this.toJSON());
    };
    P.Rectangle.prototype.translate = function(point) {
      return new P.Rectangle(this.x + point.x, this.y + point.y, this.width, this.height);
    };
    P.Rectangle.prototype.moveSide = function(sideName, destination) {
      switch (sideName) {
        case 'left':
          this.x = destination;
          break;
        case 'right':
          this.x = destination - this.width;
          break;
        case 'top':
          this.y = destination;
          break;
        case 'bottom':
          this.y = destination - this.height;
      }
    };
    P.Rectangle.prototype.moveCorner = function(cornerName, destination) {
      switch (cornerName) {
        case 'topLeft':
          this.x = destination.x;
          this.y = destination.y;
          break;
        case 'topRight':
          this.x = destination.x - this.width;
          this.y = destination.y;
          break;
        case 'bottomRight':
          this.x = destination.x - this.width;
          this.y = destination.y - this.height;
          break;
        case 'bottomLeft':
          this.x = destination.x;
          this.y = destination.y - this.height;
      }
    };
    P.Rectangle.prototype.moveCenter = function(destination) {
      this.x = destination.x - this.width * 0.5;
      this.y = destination.y - this.height * 0.5;
    };
    Event.prototype.toJSON = function() {
      var event;
      event = {
        modifiers: this.modifiers,
        event: {
          which: this.event.which
        },
        point: this.point,
        downPoint: this.downPoint,
        delta: this.delta,
        middlePoint: this.middlePoint,
        type: this.type,
        count: this.count
      };
      return event;
    };
    Event.prototype.fromJSON = function(event) {
      if (event.point != null) {
        event.point = new P.Point(event.point);
      }
      if (event.downPoint != null) {
        event.downPoint = new P.Point(event.downPoint);
      }
      if (event.delta != null) {
        event.delta = new P.Point(event.delta);
      }
      if (event.middlePoint != null) {
        event.middlePoint = new P.Point(event.middlePoint);
      }
      return event;
    };
  });

}).call(this);

//# sourceMappingURL=Utils.map
