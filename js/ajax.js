// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty;

  define(['utils', 'jquery', 'paper'], function(utils) {
    var g, loadCallback;
    g = utils.g();
    g.areaIsLoaded = function(pos, planet, qZoom) {
      var area, _i, _len, _ref;
      _ref = g.loadedAreas;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        area = _ref[_i];
        if (area.planet.x === planet.x && area.planet.y === planet.y) {
          if (area.pos.x === pos.x && area.pos.y === pos.y) {
            if ((qZoom == null) || area.zoom === qZoom) {
              return true;
            }
          }
        }
      }
      return false;
    };
    g.unload = function() {
      var item, pk, _ref;
      g.loadedAreas = [];
      _ref = g.items;
      for (pk in _ref) {
        if (!__hasProp.call(_ref, pk)) continue;
        item = _ref[pk];
        item.remove();
      }
      g.items = {};
      g.rasterizer.clearRasters();
      g.previousLoadPosition = null;
    };
    g.load = function(area) {
      var areaRectangle, areasToLoad, b, bounds, debug, halfSize, i, item, itemsDates, itemsOutsideLimit, j, l, limit, pk, planet, pos, qZoom, r, rectangle, removeRectangle, scale, showLoadingBar, t, unloadDist, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      if (area == null) {
        area = null;
      }
      if (!g.rasterizerMode && (g.previousLoadPosition != null)) {
        if (g.previousLoadPosition.position.subtract(view.center).length < 50) {
          if (Math.abs(1 - g.previousLoadPosition.zoom / view.zoom) < 0.2) {
            return false;
          }
        }
      }
      console.log("load");
      if (area != null) {
        console.log(area.toString());
      }
      debug = false;
      g.previousLoadPosition = {
        position: view.center,
        zoom: view.zoom
      };
      if (area == null) {
        if (view.bounds.width <= window.innerWidth && view.bounds.height <= window.innerHeight) {
          bounds = view.bounds;
        } else {
          halfSize = new Point(window.innerWidth * 0.5, window.innerHeight * 0.5);
          bounds = new Rectangle(view.center.subtract(halfSize), view.center.add(halfSize));
        }
      } else {
        bounds = area;
      }
      if (debug) {
        if ((_ref = g.unloadRectangle) != null) {
          _ref.remove();
        }
        if ((_ref1 = g.viewRectangle) != null) {
          _ref1.remove();
        }
        if ((_ref2 = g.limitRectangle) != null) {
          _ref2.remove();
        }
      }
      unloadDist = Math.round(g.scale / view.zoom);
      if (!g.entireArea) {
        limit = bounds.expand(unloadDist);
      } else {
        limit = g.entireArea;
      }
      itemsOutsideLimit = [];
      _ref3 = g.items;
      for (pk in _ref3) {
        if (!__hasProp.call(_ref3, pk)) continue;
        item = _ref3[pk];
        if (!item.getBounds().intersects(limit)) {
          itemsOutsideLimit.push(item);
        }
      }
      if (debug) {
        g.unloadRectangle = new Path.Rectangle(limit);
        g.unloadRectangle.name = 'debug load unload rectangle';
        g.unloadRectangle.strokeWidth = 1;
        g.unloadRectangle.strokeColor = 'red';
        g.unloadRectangle.dashArray = [10, 4];
        g.debugLayer.addChild(g.unloadRectangle);
      }
      if (debug) {
        removeRectangle = function(rectangle) {
          var removeRect;
          removeRect = function() {
            return rectangle.remove();
          };
          setTimeout(removeRect, 1500);
        };
      }
      g.rasterizer.unload(limit);
      qZoom = g.quantizeZoom(1.0 / view.zoom);
      i = g.loadedAreas.length;
      while (i--) {
        area = g.loadedAreas[i];
        pos = g.posOnPlanetToProject(area.pos, area.planet);
        rectangle = new Rectangle(pos.x, pos.y, g.scale * area.zoom, g.scale * area.zoom);
        if (!rectangle.intersects(limit) || area.zoom !== qZoom) {
          if (debug) {
            area.rectangle.strokeColor = 'red';
            removeRectangle(area.rectangle);
          }
          g.loadedAreas.splice(i, 1);
          j = itemsOutsideLimit.length;
          while (j--) {
            item = itemsOutsideLimit[j];
            if (item.getBounds().intersects(rectangle)) {
              item.remove();
              itemsOutsideLimit.splice(j, 1);
            }
          }
        }
      }
      itemsOutsideLimit = null;
      scale = g.scale * qZoom;
      t = g.floorToMultiple(bounds.top, scale);
      l = g.floorToMultiple(bounds.left, scale);
      b = g.floorToMultiple(bounds.bottom, scale);
      r = g.floorToMultiple(bounds.right, scale);
      if (debug) {
        g.viewRectangle = new Path.Rectangle(bounds);
        g.viewRectangle.name = 'debug load view rectangle';
        g.viewRectangle.strokeWidth = 1;
        g.viewRectangle.strokeColor = 'blue';
        g.debugLayer.addChild(g.viewRectangle);
        g.limitRectangle = new Path.Rectangle(new Point(l, t), new Point(r, b));
        g.limitRectangle.name = 'debug load limit rectangle';
        g.limitRectangle.strokeWidth = 2;
        g.limitRectangle.strokeColor = 'blue';
        g.limitRectangle.dashArray = [10, 4];
        g.debugLayer.addChild(g.limitRectangle);
      }
      areasToLoad = [];
      for (x = _i = l; scale > 0 ? _i <= r : _i >= r; x = _i += scale) {
        for (y = _j = t; scale > 0 ? _j <= b : _j >= b; y = _j += scale) {
          planet = g.projectToPlanet(new Point(x, y));
          pos = g.projectToPosOnPlanet(new Point(x, y));
          if (g.rasterizerMode) {
            if (debug) {
              areaRectangle = new Path.Rectangle(x, y, scale, scale);
              areaRectangle.name = 'debug load area rectangle';
              areaRectangle.strokeWidth = 1;
              areaRectangle.strokeColor = 'green';
              g.debugLayer.addChild(areaRectangle);
            }
            area = {
              pos: pos,
              planet: planet
            };
            areasToLoad.push(area);
            if (debug) {
              area.rectangle = areaRectangle;
            }
            if (!g.areaIsLoaded(pos, planet)) {
              g.loadedAreas.push(area);
            }
          } else {
            if (!g.areaIsLoaded(pos, planet, qZoom)) {
              if (debug) {
                areaRectangle = new Path.Rectangle(x, y, scale, scale);
                areaRectangle.name = 'debug load area rectangle';
                areaRectangle.strokeWidth = 1;
                areaRectangle.strokeColor = 'green';
                g.debugLayer.addChild(areaRectangle);
              }
              area = {
                pos: pos,
                planet: planet
              };
              areasToLoad.push(area);
              area.zoom = qZoom;
              if (debug) {
                area.rectangle = areaRectangle;
              }
              g.loadedAreas.push(area);
            }
          }
        }
      }
      if (!g.rasterizerMode && areasToLoad.length <= 0) {
        return false;
      }
      if (g.loadingBarTimeout == null) {
        showLoadingBar = function() {
          $("#loadingBar").show();
        };
        g.loadingBarTimeout = setTimeout(showLoadingBar, 0);
      }
      if (!g.rasterizerMode) {
        rectangle = {
          left: l / 1000.0,
          top: t / 1000.0,
          right: r / 1000.0,
          bottom: b / 1000.0
        };
        Dajaxice.draw.load(loadCallback, {
          rectangle: rectangle,
          areasToLoad: areasToLoad,
          qZoom: qZoom,
          city: g.city
        });
      } else {
        itemsDates = g.createItemsDates(bounds);
        console.log('itemsDates');
        console.log(itemsDates);
        Dajaxice.draw.loadRasterizer(loadCallback, {
          areasToLoad: areasToLoad,
          itemsDates: itemsDates,
          cityPk: g.city
        });
      }
      return true;
    };
    g.dispatchLoadFinished = function() {
      var commandEvent;
      console.log("dispatch command executed");
      commandEvent = document.createEvent('Event');
      commandEvent.initEvent('command executed', true, true);
      document.dispatchEvent(commandEvent);
    };
    loadCallback = function(results) {
      var box, data, date, deletedItemLastUpdate, div, i, item, itemToReplace, itemsToLoad, lock, path, pk, planet, point, points, rdiv, rpath, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      console.log("load callback");
      console.log(project.activeLayer.name);
      if (!g.checkError(results)) {
        return;
      }
      if (results.hasOwnProperty('message') && results.message === 'no_paths') {
        g.dispatchLoadFinished();
        return;
      }
      if ((g.me == null) && (results.user != null)) {
        g.me = results.user;
        if ((g.chatJ != null) && g.chatJ.find("#chatUserNameInput").length === 0) {
          g.startChatting(g.me);
        }
      }
      if (results.rasters != null) {
        g.rasterizer.load(results.rasters, results.qZoom);
      }
      if (results.deletedItems != null) {
        _ref = results.deletedItems;
        for (pk in _ref) {
          deletedItemLastUpdate = _ref[pk];
          if ((_ref1 = g.items[pk]) != null) {
            _ref1.remove();
          }
        }
      }
      itemsToLoad = [];
      _ref2 = results.items;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        i = _ref2[_i];
        item = JSON.parse(i);
        if (!g.rasterizerMode && (g.items[item._id.$oid] != null)) {
          continue;
        } else if (g.rasterizerMode) {
          itemToReplace = g.items[item._id.$oid];
          if (itemToReplace != null) {
            console.log("itemToReplace: " + itemToReplace.pk);
            itemToReplace.remove();
          }
        }
        if (item.rType === 'Box') {
          box = item;
          if (box.box.coordinates[0].length < 5) {
            console.log("Error: box has less than 5 points");
          }
          data = (box.data != null) && box.data.length > 0 ? JSON.parse(box.data) : null;
          date = box.date.$date;
          lock = null;
          switch (box.object_type) {
            case 'link':
              lock = new g.RLink(g.rectangleFromBox(box), data, box._id.$oid, box.owner, date, (_ref3 = box.module) != null ? _ref3.$oid : void 0);
              break;
            case 'lock':
              lock = new g.RLock(g.rectangleFromBox(box), data, box._id.$oid, box.owner, date, (_ref4 = box.module) != null ? _ref4.$oid : void 0);
              break;
            case 'website':
              lock = new g.RWebsite(g.rectangleFromBox(box), data, box._id.$oid, box.owner, date, (_ref5 = box.module) != null ? _ref5.$oid : void 0);
              break;
            case 'video-game':
              lock = new g.RVideoGame(g.rectangleFromBox(box), data, box._id.$oid, box.owner, date, (_ref6 = box.module) != null ? _ref6.$oid : void 0);
          }
          lock.lastUpdateDate = box.lastUpdate.$date;
        } else {
          itemsToLoad.push(item);
        }
      }
      for (_j = 0, _len1 = itemsToLoad.length; _j < _len1; _j++) {
        item = itemsToLoad[_j];
        pk = item._id.$oid;
        date = (_ref7 = item.date) != null ? _ref7.$date : void 0;
        data = (item.data != null) && item.data.length > 0 ? JSON.parse(item.data) : null;
        lock = item.lock != null ? g.items[item.lock] : null;
        switch (item.rType) {
          case 'Div':
            div = item;
            if (div.box.coordinates[0].length < 5) {
              console.log("Error: box has less than 5 points");
            }
            switch (div.object_type) {
              case 'text':
                rdiv = new g.RText(g.rectangleFromBox(div), data, pk, date, lock);
                break;
              case 'media':
                rdiv = new g.RMedia(g.rectangleFromBox(div), data, pk, date, lock);
            }
            rdiv.lastUpdateDate = div.lastUpdate.$date;
            break;
          case 'Path':
            path = item;
            planet = new Point(path.planetX, path.planetY);
            if (data != null) {
              data.planet = planet;
            }
            points = [];
            _ref8 = path.points.coordinates;
            for (_k = 0, _len2 = _ref8.length; _k < _len2; _k++) {
              point = _ref8[_k];
              points.push(g.posOnPlanetToProject(point, planet));
            }
            rpath = null;
            if (g.tools[path.object_type] != null) {
              rpath = new g.tools[path.object_type].RPath(date, data, pk, points, lock);
              rpath.lastUpdateDate = path.lastUpdate.$date;
              if (rpath.constructor.name === "Checkpoint") {
                console.log(rpath);
              }
            } else {
              console.log("Unknown path type: " + path.object_type);
            }
            break;
          case 'AreaToUpdate':
            g.rasterizer.addAreaToUpdate(g.rectangleFromBox(item));
            break;
          default:
            continue;
        }
      }
      g.rasterizer.setQZoomToUpdate(results.qZoom);
      if ((results.rasters == null) || results.rasters.length === 0) {
        g.rasterizer.rasterizeAreasToUpdate();
      }
      g.RDiv.updateZIndex(g.sortedDivs);
      if (!g.rasterizerMode) {
        clearTimeout(g.loadingBarTimeout);
        g.loadingBarTimeout = null;
        $("#loadingBar").hide();
        g.dispatchLoadFinished();
      }
      if (typeof window.saveOnServer === "function") {
        console.log("rasterizeAndSaveOnServer");
        g.rasterizeAndSaveOnServer();
      }
    };
  });

}).call(this);

//# sourceMappingURL=ajax.map
