// Generated by CoffeeScript 1.7.1
(function() {
  define(['Tools/Tool'], function(Tool) {
    if (!window.rasterizerMode) {
      return;
    }
    R.areasToRasterize = [];
    R.initializeRasterizerMode = function() {
      R.initToolsRasterizer = function() {
        var pathClass, _i, _len, _ref;
        R.modules = {};
        _ref = R.pathClasses;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pathClass = _ref[_i];
          Tool[pathClass.label] = {
            RPath: pathClass
          };
          R.modules[pathClass.label] = {
            name: pathClass.label,
            iconURL: pathClass.iconURL,
            source: pathClass.source,
            description: pathClass.description,
            owner: 'Romanesco',
            thumbnailURL: pathClass.thumbnailURL,
            accepted: true,
            coreModule: true,
            category: pathClass.category
          };
        }
        R.initializeModules();
      };
      R.fakeFunction = function() {};
      R.updateRoom = R.fakeFunction;
      Utils.deferredExecution = R.fakeFunction;
      R.alertManager.alert = R.fakeFunction;
      R.rasterizer = {
        load: R.fakeFunction,
        unload: R.fakeFunction,
        move: R.fakeFunction,
        rasterizeAreasToUpdate: R.fakeFunction,
        addAreaToUpdate: R.fakeFunction,
        setQZoomToUpdate: R.fakeFunction,
        clearRasters: R.fakeFunction
      };
      jQuery.fn.mCustomScrollbar = R.fakeFunction;
      R.selectedToolNeedsDrawings = function() {
        return true;
      };
      R.CommandManager = R.fakeFunction;
      R.Rasterizer = R.fakeFunction;
      R.initializeGlobalParameters = R.fakeFunction;
      R.initParameters = R.fakeFunction;
      R.initCodeEditor = R.fakeFunction;
      R.initSocket = R.fakeFunction;
      R.initPosition = R.fakeFunction;
      R.view.grid.update = R.fakeFunction;
      R.RSound = R.fakeFunction;
      R.chatSocket = {
        emit: R.fakeFunction
      };
      R.defaultColors = [];
      R.gui = {
        __folders: {}
      };
      R.animatedItems = [];
      R.areaToRasterize = null;
      R.createItemsDates = function(bounds) {
        var item, itemsDates, pk, type, _ref;
        itemsDates = {};
        _ref = R.items;
        for (pk in _ref) {
          item = _ref[pk];
          type = '';
          if (Lock.prototype.isPrototypeOf(item)) {
            type = 'Box';
          } else if (Div.prototype.isPrototypeOf(item)) {
            type = 'Div';
          } else if (Path.prototype.isPrototypeOf(item)) {
            type = 'Path';
          }
          itemsDates[pk] = item.lastUpdateDate;
        }
        return itemsDates;
      };
      window.loopRasterize = function() {
        var dataURL, finished, height, imagePosition, newSize, rectangle, topLeft, width;
        rectangle = R.areaToRasterize;
        width = Math.min(1000, rectangle.right - P.view.bounds.left);
        height = Math.min(1000, rectangle.bottom - P.view.bounds.top);
        newSize = new P.Size(width, height);
        if (!P.view.viewSize.equals(newSize)) {
          topLeft = P.view.bounds.topLeft;
          P.view.viewSize = newSize;
          P.view.center = topLeft.add(newSize.multiply(0.5));
        }
        imagePosition = P.view.bounds.topLeft.clone();
        dataURL = R.canvas.toDataURL();
        finished = P.view.bounds.bottom >= rectangle.bottom && P.view.bounds.right >= rectangle.right;
        if (!finished) {
          if (P.view.bounds.right < rectangle.right) {
            P.view.center = P.view.center.add(1000, 0);
          } else {
            P.view.center = new P.Point(rectangle.left + P.view.viewSize.width * 0.5, P.view.bounds.bottom + P.view.viewSize.height * 0.5);
          }
        } else {
          R.areaToRasterize = null;
        }
        window.saveOnServer(dataURL, imagePosition.x, imagePosition.y, finished, R.city);
      };
      R.loopRasterize = window.loopRasterize;
      R.rasterizeAndSaveOnServer = function() {
        console.log("area rasterized");
        P.view.viewSize = P.Size.min(new P.Size(1000, 1000), R.areaToRasterize.size);
        P.view.center = R.areaToRasterize.topLeft.add(P.view.size.multiply(0.5));
        R.loopRasterize();
      };
      window.loadArea = function(args) {
        var area, areaObject, delta, div, _i, _len, _ref;
        console.log("load_area");
        if (R.areaToRasterize != null) {
          console.log("error: load_area while loading !!");
          return;
        }
        areaObject = JSON.parse(args);
        if (areaObject.city !== R.city) {
          R.unload();
          R.city = areaObject.city;
        }
        area = Utils.Rectangle.expandRectangleToInteger(Utils.CS.rectangleFromBox(areaObject));
        R.areaToRasterize = area;
        delta = area.center.subtract(P.view.center);
        P.view.scrollBy(delta);
        _ref = R.divs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          div = _ref[_i];
          div.updateTransform();
        }
        console.log("call load");
        R.loader.load(area);
      };
      R.loadArea = window.loadArea;
      R.getAreasToUpdate = function() {
        if (R.areasToRasterize.length === 0 && R.imageSaved) {
          Dajaxice.draw.getAreasToUpdate(R.getAreasToUpdateCallback);
        }
      };
      R.loadNextArea = function() {
        var area;
        if (R.areasToRasterize.length > 0) {
          area = R.areasToRasterize.shift();
          R.areaToRasterizePk = area._id.$oid;
          R.imageSaved = false;
          R.loadArea(JSON.stringify(area));
        }
      };
      R.getAreasToUpdateCallback = function(areas) {
        R.areasToRasterize = areas;
        R.loadNextArea();
      };
      R.testSaveOnServer = function(imageDataURL, x, y, finished) {
        if (!imageDataURL) {
          console.log("no image data url");
        }
        R.rasterizedAreasJ.append($('<img src="' + imageDataURL + '" data-position="' + x + ', ' + y + '" finished="' + finished + '">').css({
          border: '1px solid black'
        }));
        console.log('position: ' + x + ', ' + y);
        console.log('finished: ' + finished);
        if (finished) {
          Dajaxice.draw.deleteAreaToUpdate(R.deleteAreaToUpdateCallback, {
            pk: R.areaToRasterizePk
          });
        } else {
          R.loopRasterize();
        }
      };
      R.deleteAreaToUpdateCallback = function(result) {
        R.loader.checkError(result);
        R.imageSaved = true;
        R.loadNextArea();
      };
      return R.testRasterizer = function() {
        R.rasterizedAreasJ = $('<div class="rasterized-areas">');
        R.rasterizedAreasJ.css({
          position: 'absolute',
          top: 1000,
          left: 0
        });
        $('body').css({
          overflow: 'auto'
        }).prepend(R.rasterizedAreasJ);
        window.saveOnServer = R.testSaveOnServer;
        R.areasToRasterize = [];
        R.imageSaved = true;
        setInterval(R.getAreasToUpdate, 1000);
      };
    };
  });

}).call(this);
