// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['utils', 'RTool'], function(utils, RTool) {
    var ItemTool;
    ItemTool = (function(_super) {
      __extends(ItemTool, _super);

      function ItemTool(RItem) {
        this.RItem = RItem;
        ItemTool.__super__.constructor.call(this, true);
        return;
      }

      ItemTool.prototype.select = function(deselectItems, updateParameters) {
        if (deselectItems == null) {
          deselectItems = true;
        }
        if (updateParameters == null) {
          updateParameters = true;
        }
        g.rasterizer.drawItems();
        ItemTool.__super__.select.apply(this, arguments);
      };

      ItemTool.prototype.begin = function(event, from) {
        var point;
        if (from == null) {
          from = g.me;
        }
        point = event.point;
        g.deselectAll();
        g.currentPaths[from] = new Path.Rectangle(point, point);
        g.currentPaths[from].name = 'div tool rectangle';
        g.currentPaths[from].dashArray = [4, 10];
        g.currentPaths[from].strokeColor = 'black';
        g.selectionLayer.addChild(g.currentPaths[from]);
        if ((g.me != null) && from === g.me) {
          g.chatSocket.emit("bounce", {
            tool: this.name,
            "function": "begin",
            "arguments": [event, g.me, g.currentPaths[from].data]
          });
        }
      };

      ItemTool.prototype.update = function(event, from) {
        var bounds, lock, locks, point, _i, _len;
        if (from == null) {
          from = g.me;
        }
        point = event.point;
        g.currentPaths[from].segments[2].point = point;
        g.currentPaths[from].segments[1].point.x = point.x;
        g.currentPaths[from].segments[3].point.y = point.y;
        g.currentPaths[from].fillColor = null;
        bounds = g.currentPaths[from].bounds;
        locks = g.RLock.getLocksWhichIntersect(bounds);
        for (_i = 0, _len = locks.length; _i < _len; _i++) {
          lock = locks[_i];
          if (lock.owner !== g.me || (this.name !== 'Lock' && !lock.rectangle.contains(bounds))) {
            g.currentPaths[from].fillColor = 'red';
          }
        }
        if (g.rectangleOverlapsTwoPlanets(bounds)) {
          g.currentPaths[from].fillColor = 'red';
        }
        if ((g.me != null) && from === g.me) {
          g.chatSocket.emit("bounce", {
            tool: this.name,
            "function": "update",
            "arguments": [event, g.me]
          });
        }
      };

      ItemTool.prototype.end = function(event, from) {
        var bounds, lock, locks, point, _i, _len;
        if (from == null) {
          from = g.me;
        }
        if (from !== g.me) {
          g.currentPaths[from].remove();
          delete g.currentPaths[from];
          return false;
        }
        point = event.point;
        g.currentPaths[from].remove();
        bounds = g.currentPaths[from].bounds;
        locks = g.RLock.getLocksWhichIntersect(bounds);
        for (_i = 0, _len = locks.length; _i < _len; _i++) {
          lock = locks[_i];
          if (lock.owner !== g.me || (this.name !== 'Lock' && !lock.rectangle.contains(bounds))) {
            g.romanesco_alert('Your item intersects with a locked area.', 'error');
            return false;
          }
        }
        if (g.rectangleOverlapsTwoPlanets(bounds)) {
          g.romanesco_alert('Your item overlaps with two planets.', 'error');
          return false;
        }
        if (g.currentPaths[from].bounds.area < 100) {
          g.currentPaths[from].width = 10;
          g.currentPaths[from].height = 10;
        }
        if ((g.me != null) && from === g.me) {
          g.chatSocket.emit("bounce", {
            tool: this.name,
            "function": "end",
            "arguments": [event, g.me]
          });
        }
        return true;
      };

      return ItemTool;

    })(RTool);
    return ItemTool;
  });

}).call(this);

//# sourceMappingURL=ItemTool.map
