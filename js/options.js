// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['utils', 'tinycolor', 'gui', 'colorpickersliders', 'jquery', 'paper'], function(utils, tinycolor, GUI) {
    var ColorController, Controller, ControllerManager, Folder, g;
    g = utils.g();
    window.tinycolor = tinycolor;
    paper.install(window);
    g.templatesJ = $("#templates");
    g.initializeGlobalParameters = function() {
      var colorName, colorRGBstring, hueRange, i, minHue, step, _i;
      g.defaultColors = [];
      g.polygonMode = false;
      g.selectionBlue = '#2fa1d6';
      hueRange = g.random(10, 180);
      minHue = g.random(0, 360 - hueRange);
      step = hueRange / 10;
      for (i = _i = 0; _i <= 10; i = ++_i) {
        g.defaultColors.push(Color.HSL(minHue + i * step, g.random(0.3, 0.9), g.random(0.5, 0.7)).toCSS());
      }
      g.parameters = {};
      g.parameters['General'] = {};
      g.parameters['General'].location = {
        type: 'string',
        label: 'Location',
        "default": '0.0, 0.0',
        permanent: true,
        onFinishChange: function(value) {
          g.ignoreHashChange = false;
          location.hash = value;
        }
      };
      g.parameters['General'].zoom = {
        type: 'slider',
        label: 'Zoom',
        min: 1,
        max: 500,
        "default": 100,
        permanent: true,
        onChange: function(value) {
          var div, _j, _len, _ref;
          g.project.view.zoom = value / 100.0;
          g.updateGrid();
          g.rasterizer.move();
          _ref = g.divs;
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            div = _ref[_j];
            div.updateTransform();
          }
        },
        onFinishChange: function(value) {
          g.load();
        }
      };
      g.parameters['General'].displayGrid = {
        type: 'checkbox',
        label: 'Display grid',
        "default": false,
        permanent: true,
        onChange: function(value) {
          g.displayGrid = !g.displayGrid;
          g.updateGrid();
        }
      };
      g.parameters['General'].ignoreSockets = {
        type: 'checkbox',
        label: 'Ignore sockets',
        "default": false,
        onChange: function(value) {
          g.ignoreSockets = value;
        }
      };
      g.parameters['General'].snap = {
        type: 'slider',
        label: 'Snap',
        min: 0,
        max: 100,
        step: 5,
        "default": 0,
        snap: 0,
        permanent: true,
        onChange: function() {
          return g.updateGrid();
        }
      };
      g.parameters["default"] = {};
      g.parameters.strokeWidth = {
        type: 'slider',
        label: 'Stroke width',
        min: 1,
        max: 100,
        "default": 1
      };
      g.parameters.strokeColor = {
        type: 'color',
        label: 'Stroke color',
        "default": g.defaultColors.random(),
        defaultFunction: function() {
          return g.defaultColors.random();
        },
        defaultCheck: true
      };
      g.parameters.fillColor = {
        type: 'color',
        label: 'Fill color',
        "default": g.defaultColors.random(),
        defaultCheck: false
      };
      g.parameters["delete"] = {
        type: 'button',
        label: 'Delete items',
        "default": function() {
          var item, selectedItems, _j, _len;
          selectedItems = g.selectedItems.slice();
          for (_j = 0, _len = selectedItems.length; _j < _len; _j++) {
            item = selectedItems[_j];
            item.deleteCommand();
          }
        }
      };
      g.parameters.duplicate = {
        type: 'button',
        label: 'Duplicate items',
        "default": function() {
          var item, _j, _len, _ref;
          _ref = g.selectedItems;
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            item = _ref[_j];
            item.duplicateCommand();
          }
        }
      };
      g.parameters.align = {
        type: 'button-group',
        label: 'Align',
        "default": '',
        initializeController: function(controller) {
          var align, alignJ, domElement;
          domElement = controller.datController.domElement;
          $(domElement).find('input').remove();
          align = function(type) {
            var avgX, avgY, bottom, bounds, item, items, left, right, top, xMax, xMin, yMax, yMin, _j, _k, _l, _len, _len1, _len10, _len11, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _s, _t, _u;
            items = g.selectedItems;
            switch (type) {
              case 'h-top':
                yMin = NaN;
                for (_j = 0, _len = items.length; _j < _len; _j++) {
                  item = items[_j];
                  top = item.getBounds().top;
                  if (isNaN(yMin) || top < yMin) {
                    yMin = top;
                  }
                }
                items.sort(function(a, b) {
                  return a.getBounds().top - b.getBounds().top;
                });
                for (_k = 0, _len1 = items.length; _k < _len1; _k++) {
                  item = items[_k];
                  bounds = item.getBounds();
                  item.moveTo(new Point(bounds.centerX, top + bounds.height / 2));
                }
                break;
              case 'h-center':
                avgY = 0;
                for (_l = 0, _len2 = items.length; _l < _len2; _l++) {
                  item = items[_l];
                  avgY += item.getBounds().centerY;
                }
                avgY /= items.length;
                items.sort(function(a, b) {
                  return a.getBounds().centerY - b.getBounds().centerY;
                });
                for (_m = 0, _len3 = items.length; _m < _len3; _m++) {
                  item = items[_m];
                  bounds = item.getBounds();
                  item.moveTo(new Point(bounds.centerX, avgY));
                }
                break;
              case 'h-bottom':
                yMax = NaN;
                for (_n = 0, _len4 = items.length; _n < _len4; _n++) {
                  item = items[_n];
                  bottom = item.getBounds().bottom;
                  if (isNaN(yMax) || bottom > yMax) {
                    yMax = bottom;
                  }
                }
                items.sort(function(a, b) {
                  return a.getBounds().bottom - b.getBounds().bottom;
                });
                for (_o = 0, _len5 = items.length; _o < _len5; _o++) {
                  item = items[_o];
                  bounds = item.getBounds();
                  item.moveTo(new Point(bounds.centerX, bottom - bounds.height / 2));
                }
                break;
              case 'v-left':
                xMin = NaN;
                for (_p = 0, _len6 = items.length; _p < _len6; _p++) {
                  item = items[_p];
                  left = item.getBounds().left;
                  if (isNaN(xMin) || left < xMin) {
                    xMin = left;
                  }
                }
                items.sort(function(a, b) {
                  return a.getBounds().left - b.getBounds().left;
                });
                for (_q = 0, _len7 = items.length; _q < _len7; _q++) {
                  item = items[_q];
                  bounds = item.getBounds();
                  item.moveTo(new Point(xMin + bounds.width / 2, bounds.centerY));
                }
                break;
              case 'v-center':
                avgX = 0;
                for (_r = 0, _len8 = items.length; _r < _len8; _r++) {
                  item = items[_r];
                  avgX += item.getBounds().centerX;
                }
                avgX /= items.length;
                items.sort(function(a, b) {
                  return a.getBounds().centerY - b.getBounds().centerY;
                });
                for (_s = 0, _len9 = items.length; _s < _len9; _s++) {
                  item = items[_s];
                  bounds = item.getBounds();
                  item.moveTo(new Point(avgX, bounds.centerY));
                }
                break;
              case 'v-right':
                xMax = NaN;
                for (_t = 0, _len10 = items.length; _t < _len10; _t++) {
                  item = items[_t];
                  right = item.getBounds().right;
                  if (isNaN(xMax) || right > xMax) {
                    xMax = right;
                  }
                }
                items.sort(function(a, b) {
                  return a.getBounds().right - b.getBounds().right;
                });
                for (_u = 0, _len11 = items.length; _u < _len11; _u++) {
                  item = items[_u];
                  bounds = item.getBounds();
                  item.moveTo(new Point(xMax - bounds.width / 2, bounds.centerY));
                }
            }
          };
          g.templatesJ.find("#align").clone().appendTo(domElement);
          alignJ = $("#align:first");
          alignJ.find("button").click(function() {
            return align($(this).attr("data-type"));
          });
        }
      };
      g.parameters.distribute = {
        type: 'button-group',
        label: 'Distribute',
        "default": '',
        initializeController: function(controller) {
          var distribute, distributeJ, domElement;
          domElement = controller.datController.domElement;
          $(domElement).find('input').remove();
          distribute = function(type) {
            var bottom, bounds, center, item, items, left, right, top, xMax, xMin, yMax, yMin, _j, _k, _l, _len, _len1, _len10, _len11, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _s, _t, _u;
            items = g.selectedItems;
            switch (type) {
              case 'h-top':
                yMin = NaN;
                yMax = NaN;
                for (_j = 0, _len = items.length; _j < _len; _j++) {
                  item = items[_j];
                  top = item.getBounds().top;
                  if (isNaN(yMin) || top < yMin) {
                    yMin = top;
                  }
                  if (isNaN(yMax) || top > yMax) {
                    yMax = top;
                  }
                }
                step = (yMax - yMin) / (items.length - 1);
                items.sort(function(a, b) {
                  return a.getBounds().top - b.getBounds().top;
                });
                for (i = _k = 0, _len1 = items.length; _k < _len1; i = ++_k) {
                  item = items[i];
                  bounds = item.getBounds();
                  item.moveTo(new Point(bounds.centerX, yMin + i * step + bounds.height / 2));
                }
                break;
              case 'h-center':
                yMin = NaN;
                yMax = NaN;
                for (_l = 0, _len2 = items.length; _l < _len2; _l++) {
                  item = items[_l];
                  center = item.getBounds().centerY;
                  if (isNaN(yMin) || center < yMin) {
                    yMin = center;
                  }
                  if (isNaN(yMax) || center > yMax) {
                    yMax = center;
                  }
                }
                step = (yMax - yMin) / (items.length - 1);
                items.sort(function(a, b) {
                  return a.getBounds().centerY - b.getBounds().centerY;
                });
                for (i = _m = 0, _len3 = items.length; _m < _len3; i = ++_m) {
                  item = items[i];
                  bounds = item.getBounds();
                  item.moveTo(new Point(bounds.centerX, yMin + i * step));
                }
                break;
              case 'h-bottom':
                yMin = NaN;
                yMax = NaN;
                for (_n = 0, _len4 = items.length; _n < _len4; _n++) {
                  item = items[_n];
                  bottom = item.getBounds().bottom;
                  if (isNaN(yMin) || bottom < yMin) {
                    yMin = bottom;
                  }
                  if (isNaN(yMax) || bottom > yMax) {
                    yMax = bottom;
                  }
                }
                step = (yMax - yMin) / (items.length - 1);
                items.sort(function(a, b) {
                  return a.getBounds().bottom - b.getBounds().bottom;
                });
                for (i = _o = 0, _len5 = items.length; _o < _len5; i = ++_o) {
                  item = items[i];
                  bounds = item.getBounds();
                  item.moveTo(new Point(bounds.centerX, yMin + i * step - bounds.height / 2));
                }
                break;
              case 'v-left':
                xMin = NaN;
                xMax = NaN;
                for (_p = 0, _len6 = items.length; _p < _len6; _p++) {
                  item = items[_p];
                  left = item.getBounds().left;
                  if (isNaN(xMin) || left < xMin) {
                    xMin = left;
                  }
                  if (isNaN(xMax) || left > xMax) {
                    xMax = left;
                  }
                }
                step = (xMax - xMin) / (items.length - 1);
                items.sort(function(a, b) {
                  return a.getBounds().left - b.getBounds().left;
                });
                for (i = _q = 0, _len7 = items.length; _q < _len7; i = ++_q) {
                  item = items[i];
                  bounds = item.getBounds();
                  item.moveTo(new Point(xMin + i * step + bounds.width / 2, bounds.centerY));
                }
                break;
              case 'v-center':
                xMin = NaN;
                xMax = NaN;
                for (_r = 0, _len8 = items.length; _r < _len8; _r++) {
                  item = items[_r];
                  center = item.getBounds().centerX;
                  if (isNaN(xMin) || center < xMin) {
                    xMin = center;
                  }
                  if (isNaN(xMax) || center > xMax) {
                    xMax = center;
                  }
                }
                step = (xMax - xMin) / (items.length - 1);
                items.sort(function(a, b) {
                  return a.getBounds().centerX - b.getBounds().centerX;
                });
                for (i = _s = 0, _len9 = items.length; _s < _len9; i = ++_s) {
                  item = items[i];
                  bounds = item.getBounds();
                  item.moveTo(new Point(xMin + i * step, bounds.centerY));
                }
                break;
              case 'v-right':
                xMin = NaN;
                xMax = NaN;
                for (_t = 0, _len10 = items.length; _t < _len10; _t++) {
                  item = items[_t];
                  right = item.getBounds().right;
                  if (isNaN(xMin) || right < xMin) {
                    xMin = right;
                  }
                  if (isNaN(xMax) || right > xMax) {
                    xMax = right;
                  }
                }
                step = (xMax - xMin) / (items.length - 1);
                items.sort(function(a, b) {
                  return a.getBounds().right - b.getBounds().right;
                });
                for (i = _u = 0, _len11 = items.length; _u < _len11; i = ++_u) {
                  item = items[i];
                  bounds = item.getBounds();
                  item.moveTo(new Point(xMin + i * step - bounds.width / 2, bounds.centerY));
                }
            }
          };
          g.templatesJ.find("#distribute").clone().appendTo(domElement);
          distributeJ = $("#distribute:first");
          distributeJ.find("button").click(function() {
            return distribute($(this).attr("data-type"));
          });
        }
      };
      colorName = g.defaultColors.random();
      colorRGBstring = tinycolor(colorName).toRgbString();
      g.strokeColor = colorRGBstring;
      g.fillColor = "rgb(255,255,255,255)";
      g.displayGrid = false;
    };
    g.initializeGlobalParameters();
    g.initParameters = function() {
      var generalFolder, jqxhr, name, parameter, _ref;
      g.optionsJ = $(".option-list");
      g.controllerManager = new g.ControllerManager();
      generalFolder = new g.Folder('General');
      _ref = g.parameters['General'];
      for (name in _ref) {
        parameter = _ref[name];
        g.controllerManager.createController(name, parameter, generalFolder);
      }
      g.addRasterizerParameters();
      g.availableFonts = [];
      g.usedFonts = [];
      jQuery.support.cors = true;
      jqxhr = $.getJSON("https://www.googleapis.com/webfonts/v1/webfonts?key=AIzaSyBVfBj_ugQO_w0AK1x9F6yiXByhcNgjQZU", g.initTextOptions);
      jqxhr.done(function(json) {
        console.log('done');
        g.initTextOptions(json);
      });
      jqxhr.fail(function(jqxhr, textStatus, error) {
        var err;
        err = textStatus + ", " + error;
        console.log('failed: ' + err);
      });
      return jqxhr.always(function(jqxhr, textStatus, error) {
        var err;
        err = textStatus + ", " + error;
        console.log('always: ' + err);
      });
    };
    g.addFont = function(fontFamily, effect) {
      var effects, font, fontAlreadyUsed, fontFamilyURL, _i, _len, _ref;
      if (fontFamily == null) {
        return;
      }
      fontFamilyURL = fontFamily.split(" ").join("+");
      fontAlreadyUsed = false;
      _ref = g.usedFonts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        font = _ref[_i];
        if (font.family === fontFamilyURL) {
          if (font.effects.indexOf(effect) === -1 && (effect != null)) {
            font.effects.push(effect);
          }
          fontAlreadyUsed = true;
          break;
        }
      }
      if (!fontAlreadyUsed) {
        effects = [];
        if (effect != null) {
          effects.push(effect);
        }
        if (!fontFamilyURL || fontFamilyURL === '') {
          console.log('ERROR: font family URL is null or empty');
        }
        g.usedFonts.push({
          family: fontFamilyURL,
          effects: effects
        });
      }
    };
    g.loadFonts = function() {
      var effect, font, fontLink, i, newFont, _i, _j, _len, _len1, _ref, _ref1;
      $('head').remove("link.fonts");
      _ref = g.usedFonts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        font = _ref[_i];
        newFont = font.family;
        if ($('head').find('link[data-font-family="' + font.family + '"]').length === 0) {
          if (font.effects.length > 0 && !(font.effects.length === 1 && font.effects.first() === 'none')) {
            newFont += "&effect=";
            _ref1 = font.effects;
            for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
              effect = _ref1[i];
              newFont += effect + '|';
            }
            newFont = newFont.slice(0, -1);
          }
          fontLink = $('<link class="fonts" data-font-family="' + font.family + '" rel="stylesheet" type="text/css">');
          fontLink.attr('href', "http://fonts.googleapis.com/css?family=" + newFont);
          $('head').append(fontLink);
        }
      }
    };
    g.initTextOptions = function(data, textStatus, jqXHR) {
      var fontFamilyNames, item, promise, _i, _len, _ref;
      fontFamilyNames = [];
      _ref = data.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        fontFamilyNames.push({
          value: item.family
        });
      }
      g.typeaheadFontEngine = new Bloodhound({
        name: 'Font families',
        local: fontFamilyNames,
        datumTokenizer: Bloodhound.tokenizers.obj.whitespace('value'),
        queryTokenizer: Bloodhound.tokenizers.whitespace
      });
      promise = g.typeaheadFontEngine.initialize();
      g.availableFonts = data.items;
    };
    Controller = (function() {
      function Controller(name, parameter, folder) {
        this.name = name;
        this.parameter = parameter;
        this.folder = folder;
        this.onChange = __bind(this.onChange, this);
        this.folder.controllers[this.name] = this;
        this.initialize();
        return;
      }

      Controller.prototype.initialize = function() {
        var controllerBox, firstOptionalParameter, _base;
        if ((_base = this.parameter).value == null) {
          _base.value = this.parameter["default"];
        }
        firstOptionalParameter = this.parameter.min != null ? this.parameter.min : this.parameter.values;
        controllerBox = this.folder.datFolder.add(this.parameter, 'value', firstOptionalParameter, this.parameter.max).name(this.parameter.label).onChange(this.parameter.onChange || this.onChange).onFinishChange(this.parameter.onFinishChange);
        this.datController = this.folder.datFolder.__controllers.last();
        if (this.parameter.step != null) {
          this.datController.step(this.parameter.step);
        }
      };

      Controller.prototype.onChange = function(value) {
        var item, _i, _len, _ref, _ref1;
        g.c = this;
        _ref = g.selectedItems;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (typeof ((_ref1 = item.data) != null ? _ref1[this.name] : void 0) !== 'undefined') {
            item.setParameterCommand(this, value);
          }
        }
      };

      Controller.prototype.getValue = function() {
        return this.datController.getValue();
      };

      Controller.prototype.setValue = function(value) {
        var _base;
        this.datController.object[this.datController.property] = value;
        this.datController.updateDisplay();
        if (typeof (_base = this.parameter).setValue === "function") {
          _base.setValue(value);
        }
      };

      Controller.prototype.remove = function() {
        this.parameter.controller = null;
        if (this.defaultOnChange) {
          this.parameter.onChange = null;
        }
        this.folder.datFolder.remove(this.datController);
        this.folder.datFolder.__controllers.remove(this.datController);
        delete this.folder.controllers[this.name];
        if (Object.keys(this.folder.controllers).length === 0) {
          this.folder.remove();
        }
        this.folder = null;
        this.name = null;
      };

      return Controller;

    })();
    g.Controller = Controller;
    ColorController = (function(_super) {
      __extends(ColorController, _super);

      ColorController.initialize = function() {
        this.containerJ = g.templatesJ.find('.color-picker');
        this.colorPickerJ = this.containerJ.find('.color-picker-slider');
        this.colorTypeSelectorJ = this.containerJ.find('[name="color-type"]');
        this.options = {
          title: 'Color picker',
          flat: true,
          size: 'sm',
          color: 'blue',
          order: {
            hsl: 1,
            rgb: 2,
            opacity: 3,
            preview: 4
          },
          labels: {
            rgbred: 'Red',
            rgbgreen: 'Green',
            rgbblue: 'Blue',
            hslhue: 'Hue',
            hslsaturation: 'Saturation',
            hsllightness: 'Lightness',
            preview: 'Preview',
            opacity: 'Opacity'
          },
          onchange: this.onColorPickerChange,
          swatches: false
        };
        this.colorPickerJ = this.colorPickerJ.ColorPickerSliders(this.options);
        this.colorTypeSelectorJ.change(this.onColorTypeChange);
      };

      ColorController.popoverContent = function() {
        return ColorController.containerJ;
      };

      ColorController.onColorPickerChange = function(container, color) {
        var _ref;
        if ((_ref = ColorController.controller) != null) {
          _ref.onColorPickerChange(container, color);
        }
      };

      ColorController.onColorTypeChange = function(event) {
        var _ref;
        if ((_ref = ColorController.controller) != null) {
          _ref.onColorTypeChange(event.target.value);
        }
      };

      ColorController.initialize();

      function ColorController(name, parameter, folder) {
        this.name = name;
        this.parameter = parameter;
        this.folder = folder;
        this.enableCheckboxChanged = __bind(this.enableCheckboxChanged, this);
        this.onChange = __bind(this.onChange, this);
        this.popoverOnHide = __bind(this.popoverOnHide, this);
        this.popoverOnShown = __bind(this.popoverOnShown, this);
        this.popoverOnShow = __bind(this.popoverOnShow, this);
        this.gradientTool = g.tools['Gradient'];
        this.selectTool = g.tools['Select'];
        ColorController.__super__.constructor.call(this, this.name, this.parameter, this.folder);
        return;
      }

      ColorController.prototype.initialize = function() {
        var value;
        value = this.parameter.value;
        if ((value != null ? value.gradient : void 0) != null) {
          this.gradient = value;
          this.parameter.value = 'black';
        }
        ColorController.__super__.initialize.call(this);
        this.colorInputJ = $(this.datController.domElement).find('input');
        this.colorInputJ.popover({
          title: this.parameter.label,
          container: 'body',
          placement: 'auto',
          content: this.constructor.popoverContent,
          html: true
        });
        this.colorInputJ.addClass("color-input");
        this.enableCheckboxJ = $('<input type="checkbox">');
        this.enableCheckboxJ.insertBefore(this.colorInputJ);
        this.colorInputJ.on('show.bs.popover', this.popoverOnShow);
        this.colorInputJ.on('shown.bs.popover', this.popoverOnShown);
        this.colorInputJ.on('hide.bs.popover', this.popoverOnHide);
        this.colorInputJ.on('hide.bs.popover', this.popoverOnHidden);
        this.enableCheckboxJ.change(this.enableCheckboxChanged);
        this.setColor(value, false);
      };

      ColorController.prototype.popoverOnShow = function(event) {
        var previousController;
        previousController = this.constructor.controller;
        if (previousController && previousController !== this) {
          previousController.colorInputJ.popover('hide');
        }
      };

      ColorController.prototype.popoverOnShown = function(event) {
        this.constructor.controller = this;
        this.gradientTool.controller = this;
        this.setColor(this.getValue());
        if (this.gradient) {
          this.gradientTool.select();
        }
      };

      ColorController.prototype.popoverOnHide = function() {
        var popoverJ, size;
        popoverJ = $('#' + $(this).attr('aria-describedby'));
        size = new Size(popoverJ.width(), popoverJ.height());
        popoverJ.find('.color-picker').appendTo(g.templatesJ.find(".color-picker-container"));
        popoverJ.width(size.width).height(size.height);
        this.constructor.controller = null;
        this.gradientTool.controller = null;
        if (this.gradient) {
          this.selectTool.select();
        }
      };

      ColorController.prototype.popoverOnHidden = function() {};

      ColorController.prototype.onChange = function(value) {
        if ((value != null ? value.gradient : void 0) != null) {
          this.gradient = value;
        } else {
          this.gradient = null;
        }
        ColorController.__super__.onChange.call(this, value);
      };

      ColorController.prototype.onColorPickerChange = function(container, color) {
        color = color.tiny.toRgbString();
        this.setColor(color, false);
        if (this.gradient != null) {
          this.gradientTool.colorChange(color, this);
        } else {
          this.onChange(color);
        }
        this.enableCheckboxJ[0].checked = true;
      };

      ColorController.prototype.onColorTypeChange = function(value) {
        switch (value) {
          case 'flat-color':
            this.gradient = null;
            this.onChange(this.getValue());
            this.selectTool.select();
            break;
          case 'linear-gradient':
            this.gradientTool.controller = this;
            this.gradientTool.setRadial(false);
            break;
          case 'radial-gradient':
            this.gradientTool.controller = this;
            this.gradientTool.setRadial(true);
        }
      };

      ColorController.prototype.getValue = function() {
        if (this.enableCheckboxJ[0].checked) {
          return this.gradient || this.colorInputJ.val();
        } else {
          return null;
        }
      };

      ColorController.prototype.setValue = function(value, updateTool) {
        if (updateTool == null) {
          updateTool = true;
        }
        ColorController.__super__.setValue.call(this, value);
        if ((value != null ? value.gradient : void 0) != null) {
          this.gradient = value;
        } else {
          this.gradient = null;
        }
        this.setColor(value);
        if (updateTool) {
          if (this.gradient != null) {
            this.gradientTool.controller = this;
            this.gradientTool.select(false, false);
          } else {
            this.selectTool.select(false, false);
          }
        }
      };

      ColorController.prototype.setColor = function(color, updateColorPicker) {
        var c, colors, stop, _i, _len, _ref, _ref1;
        if (updateColorPicker == null) {
          updateColorPicker = true;
        }
        this.enableCheckboxJ[0].checked = color != null;
        if (this.gradient) {
          this.colorInputJ.val('Gradient');
          colors = '';
          _ref = this.gradient.gradient.stops;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            stop = _ref[_i];
            c = new Color(stop.color != null ? stop.color : stop[0]);
            colors += ', ' + c.toCSS();
          }
          this.colorInputJ.css({
            'background-color': ''
          });
          this.colorInputJ.css({
            'background-image': 'linear-gradient( to right' + colors + ')'
          });
          if ((_ref1 = this.gradient.gradient) != null ? _ref1.radial : void 0) {
            this.constructor.colorTypeSelectorJ.find('[value="radial-gradient"]').prop('selected', true);
          } else {
            this.constructor.colorTypeSelectorJ.find('[value="linear-gradient"]').prop('selected', true);
          }
        } else {
          this.colorInputJ.val(color);
          this.colorInputJ.css({
            'background-image': ''
          });
          this.colorInputJ.css({
            'background-color': color || 'transparent'
          });
          this.constructor.colorTypeSelectorJ.find('[value="flat-color"]').prop('selected', true);
        }
        if (updateColorPicker) {
          this.constructor.colorPickerJ.trigger("colorpickersliders.updateColor", [color, true]);
        }
      };

      ColorController.prototype.enableCheckboxChanged = function(event) {
        var value;
        value = this.getValue();
        this.onChange(value);
        this.setColor(value, false);
      };

      ColorController.prototype.remove = function() {
        this.onChange = function() {};
        this.colorInputJ.popover('destroy');
        ColorController.__super__.remove.call(this);
      };

      return ColorController;

    })(g.Controller);
    g.ColorController = ColorController;
    Folder = (function() {
      function Folder(name, closedByDefault, parentFolder) {
        this.name = name;
        if (closedByDefault == null) {
          closedByDefault = false;
        }
        this.parentFolder = parentFolder;
        this.controllers = {};
        this.folders = {};
        if (!this.parentFolder) {
          g.controllerManager.folders[this.name] = this;
          this.datFolder = g.gui.addFolder(this.name);
        } else {
          this.parentFolder.folders[this.name] = this;
          this.datFolder = this.parentFolder.datFolder.addFolder(this.name);
        }
        if (!closedByDefault) {
          this.datFolder.open();
        }
        return;
      }

      Folder.prototype.remove = function() {
        var controller, folder, name, _ref, _ref1;
        _ref = this.controllers;
        for (name in _ref) {
          controller = _ref[name];
          controller.remove();
          delete this.controller[name];
        }
        _ref1 = this.folders;
        for (name in _ref1) {
          folder = _ref1[name];
          folder.remove();
          delete this.folders[name];
        }
        this.datFolder.close();
        $(this.datFolder.domElement).parent().remove();
        delete this.datFolder.parent.__folders[this.datFolder.name];
        g.gui.onResize();
        delete g.controllerManager.folders[this.name];
      };

      return Folder;

    })();
    g.Folder = Folder;
    ControllerManager = (function() {
      function ControllerManager() {
        this.updateParametersForSelectedItemsCallback = __bind(this.updateParametersForSelectedItemsCallback, this);
        var toggleGuiButtonJ;
        dat.GUI.autoPace = false;
        g.gui = new dat.GUI();
        dat.GUI.toggleHide = function() {};
        this.folders = {};
        g.templatesJ.find("button.dat-gui-toggle").clone().appendTo(g.gui.domElement);
        toggleGuiButtonJ = $(g.gui.domElement).find("button.dat-gui-toggle");
        toggleGuiButtonJ.click(this.toggleGui);
        if ((localStorage.optionsBarPosition != null) && localStorage.optionsBarPosition === 'sidebar') {
          $(".dat-gui.dg-sidebar").append(g.gui.domElement);
        } else {
          $(".dat-gui.dg-right").append(g.gui.domElement);
        }
        return;
      }

      ControllerManager.prototype.toggleGui = function() {
        var parentJ;
        parentJ = $(g.gui.domElement).parent();
        if (parentJ.hasClass("dg-sidebar")) {
          $(".dat-gui.dg-right").append(g.gui.domElement);
          localStorage.optionsBarPosition = 'right';
        } else if (parentJ.hasClass("dg-right")) {
          $(".dat-gui.dg-sidebar").append(g.gui.domElement);
          localStorage.optionsBarPosition = 'sidebar';
        }
      };

      ControllerManager.prototype.removeUnusedControllers = function() {
        var controller, folder, folderName, name, _ref, _ref1;
        _ref = this.folders;
        for (folderName in _ref) {
          folder = _ref[folderName];
          if (folder.name === 'General') {
            continue;
          }
          _ref1 = folder.controllers;
          for (name in _ref1) {
            controller = _ref1[name];
            if (!controller.used) {
              controller.remove();
            } else {
              controller.used = false;
            }
          }
        }
      };

      ControllerManager.prototype.updateHeight = function() {};

      ControllerManager.prototype.createController = function(name, parameter, folder) {
        var controller;
        controller = null;
        switch (parameter.type) {
          case 'color':
            controller = new g.ColorController(name, parameter, folder);
            break;
          default:
            controller = new g.Controller(name, parameter, folder);
        }
        return controller;
      };

      ControllerManager.prototype.initializeControllers = function() {
        var controller, folder, folderName, name, _base, _ref, _ref1;
        _ref = this.folders;
        for (folderName in _ref) {
          folder = _ref[folderName];
          _ref1 = folder.controllers;
          for (name in _ref1) {
            controller = _ref1[name];
            if (typeof (_base = controller.parameter).initializeController === "function") {
              _base.initializeController(controller);
            }
          }
        }
      };

      ControllerManager.prototype.initializeValue = function(name, parameter, firstItem) {
        var value, _ref;
        value = null;
        if ((firstItem != null ? (_ref = firstItem.data) != null ? _ref[name] : void 0 : void 0) !== void 0) {
          value = firstItem.data[name];
        } else if (parameter["default"] != null) {
          value = parameter["default"];
        } else if (parameter.defaultFunction != null) {
          value = parameter.defaultFunction();
        }
        return value;
      };

      ControllerManager.prototype.updateControllers = function(tools, resetValues) {
        var controller, folder, folderName, folderParameters, name, parameter, tool, _ref;
        if (resetValues == null) {
          resetValues = false;
        }
        for (name in tools) {
          tool = tools[name];
          _ref = tool.parameters;
          for (folderName in _ref) {
            folderParameters = _ref[folderName];
            if (folderName === 'General') {
              continue;
            }
            folder = this.folders[folderName];
            if (folder == null) {
              folder = new g.Folder(folderName, folderParameters.folderIsClosedByDefault);
            }
            for (name in folderParameters) {
              parameter = folderParameters[name];
              if (name === 'folderIsClosedByDefault') {
                continue;
              }
              controller = folder.controllers[name];
              parameter.value = this.initializeValue(name, parameter, tool.items.first());
              if (controller != null) {
                if (resetValues) {
                  controller.setValue(parameter.value, false);
                }
              } else {
                if (controller == null) {
                  controller = this.createController(name, parameter, folder);
                }
              }
              parameter.controller = controller;
              controller.used = true;
            }
          }
        }
        this.removeUnusedControllers();
        this.initializeControllers();
      };

      ControllerManager.prototype.updateParametersForSelectedItems = function() {
        g.callNextFrame(this.updateParametersForSelectedItemsCallback, 'updateParametersForSelectedItems');
      };

      ControllerManager.prototype.updateParametersForSelectedItemsCallback = function() {
        var item, tools, _i, _len, _name, _ref;
        tools = {};
        _ref = g.selectedItems;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (tools[_name = item.constructor.name] == null) {
            tools[_name] = {
              parameters: item.constructor.parameters,
              items: []
            };
          }
          tools[item.constructor.name].items.push(item);
        }
        this.updateControllers(tools, true);
      };

      ControllerManager.prototype.setSelectedTool = function(tool) {
        var tools;
        g.cancelCallNextFrame('updateParametersForSelectedItems');
        tools = {};
        tools[tool.name] = {
          parameters: tool.parameters,
          items: []
        };
        this.updateControllers(tools, false);
      };

      ControllerManager.prototype.updateItemData = function(item) {
        var controller, folder, name, _base, _name, _ref, _ref1;
        _ref = this.folders;
        for (name in _ref) {
          folder = _ref[name];
          if (name === 'General' || name === 'Items') {
            continue;
          }
          _ref1 = folder.controllers;
          for (name in _ref1) {
            controller = _ref1[name];
            if ((_base = item.data)[_name = controller.name] == null) {
              _base[_name] = controller.getValue();
            }
          }
        }
      };

      return ControllerManager;

    })();
    g.ControllerManager = ControllerManager;
  });

}).call(this);

//# sourceMappingURL=options.map
